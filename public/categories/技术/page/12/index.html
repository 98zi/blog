<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>技术 | 子舒的博客</title><meta name=keywords content><meta name=description content="子舒的博客，记录生活"><meta name=author content="子舒"><link rel=canonical href=/categories/%E6%8A%80%E6%9C%AF/><link crossorigin=anonymous href=/assets/css/stylesheet.5ea1a2f851c645871793276dce298322e6dbf894e6328ec3a0b36446942b7f71.css integrity="sha256-XqGi+FHGRYcXkydtzimDIubb+JTmMo7DoLNkRpQrf3E=" rel="preload stylesheet" as=style><link rel=icon href=https://img.zburu.com/favicon.ico><link rel=mask-icon href=/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=/categories/%E6%8A%80%E6%9C%AF/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="技术"><meta property="og:description" content="子舒的博客，记录生活"><meta property="og:type" content="website"><meta property="og:url" content="/categories/%E6%8A%80%E6%9C%AF/"><meta property="og:image" content="/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="技术"><meta name=twitter:description content="子舒的博客，记录生活"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=/ accesskey=h title="子舒的博客 (Alt + H)">子舒的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=/categories/ title=categories><span>categories</span></a></li><li><a href=/message/ title=message><span>message</span></a></li><li><a href=/lab/ title=lab><span>lab</span></a></li><li><a href=/about/ title=about><span>about</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>技术
<a href=/categories/%E6%8A%80%E6%9C%AF/index.xml title=RSS aria-label=RSS><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2>如何在 React 中引入 less？</h2></header><div class=entry-content><p>本文主要写如何在 React 中引入 less 。因为 less 和 css 非常像，因此很容易学习。而且 less 仅对 css 语言增加了少许方便的扩展，这就是 less 如此易学的原因之一。
1.安装 less npm install less less-loader --save-dev 2.暴露 webpack 文件 利用 npx create-react-app 搭建的 React 项目，默认隐藏 webpack 配置文件，引入 less 需要修改 webpack 配置文件，因此我们需要执行命令暴露 webpack 配置文件。
这里需要注意，一旦暴露，无法回退。
npm run eject 如果这一步失败，执行下列命令：
git add . git commit -m "init" 然后再执行 npm run eject
注意：暴露 webpack 文件只能在 create-react-app 之初，一旦项目结构发生改变，再进行暴露操作就会失败。所以尽量在项目建立时就进行 npm run eject 操作。
3.修改 wenpack.config.js 配置 在合适的位置添加：
// 放在 // const sassRegex = /\....</p></div><footer class=entry-footer><span title='2021-01-04 00:00:00 +0000 UTC'>January 4, 2021</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;196 words&nbsp;·&nbsp;子舒</footer><a class=entry-link aria-label="post link to 如何在 React 中引入 less？" href=/blog/41.html/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>为什么 key 是必须的？</h2></header><div class=entry-content><p>之前有说到，在 React 中渲染列表的时候，要给每一个数据加一个 key 值，赋予一个确定的标示，而且也详细描述了如何给一个标示，方法知道了，那么为什么要这么做呢？
在 React 中如何渲染列表？
在默认条件下，当递归 DOM 节点的子元素时，React 会同时遍历两个子元素的列表；当产生差异时，生成一个 mutation。
在子元素列表末尾新增元素时，更新开销比较小。比如：
&lt;ul> &lt;li>first&lt;/li> &lt;li>second&lt;/li> &lt;/ul> &lt;ul> &lt;li>first&lt;/li> &lt;li>second&lt;/li> &lt;li>third&lt;/li> &lt;/ul> React 会先匹配两个 &lt;li>first&lt;/li> 对应的树，然后匹配第二个元素 &lt;li>second&lt;/li> 对应的树，最后插入第三个元素的 &lt;li>third&lt;/li> 树。
如果只是简单的将新增元素插入到表头，那么更新开销会比较大。比如：
&lt;ul> &lt;li>Duke&lt;/li> &lt;li>Villanova&lt;/li> &lt;/ul> &lt;ul> &lt;li>Connecticut&lt;/li> &lt;li>Duke&lt;/li> &lt;li>Villanova&lt;/li> &lt;/ul> React 不会意识到应该保留 &lt;li>Duke&lt;/li> 和 &lt;li>Villanova&lt;/li>，而是会重建每一个子元素 。这种情况会带来性能问题。
key
为了解决上述问题， React 支持 key 属性，当子元素拥有 key 时，React 使用 key 来匹配原有树上的子元素以及最新树上的子元素。以下例子在新增 key 之后使得之前的低效转换变得高效：
&lt;ul> &lt;li key="1">Duke&lt;/li> &lt;li key="2">Villanova&lt;/li> &lt;/ul> &lt;ul> &lt;li key="0">Connecticut&lt;/li> &lt;li key="1">Duke&lt;/li> &lt;li key="2">Villanova&lt;/li> &lt;/ul> 现在 React 知道只有带着 '0' key 的元素是新元素，带着 '1' 以及 '2' key 的元素仅仅移动了。...</p></div><footer class=entry-footer><span title='2021-01-01 00:00:00 +0000 UTC'>January 1, 2021</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;111 words&nbsp;·&nbsp;子舒</footer><a class=entry-link aria-label="post link to 为什么 key 是必须的？" href=/blog/40.html/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>React 学习笔记（三）</h2></header><div class=entry-content><p>来源于：https://react.docschina.org/docs/forms.html
一、表单 在 React 中，html 表单元素的工作方式和其他的 DOM 元素不太一样，因为表单内部通常会保持一些内部的 state，比如下面这个纯 html 表单只接受一个名称：
&lt;form> &lt;label> 名字: &lt;input type="text" name="name" /> &lt;/label> &lt;input type="submit" value="提交" /> &lt;/form> 这个表单具有默认的 html 表单行为，即在用户提交表单之后自动刷新页面。如果你在 React 中执行相同的代码，它仍然有效。
但大多数情况下，使用 JavaScript 函数可以很方便的处理表单的提交， 同时还可以访问用户填写的表单数据。实现这种效果的标准方式是使用“受控组件”。
受控组件 在 html 中，表单元素比如&lt;input>，&lt;textarea>，&lt;select>，这些表单元素通常自己维护 state，并根据用户输入进行更新。而在 React 中，可变状态（mutable state）通常保存在组件的 state 属性中，并且只能通过使用 setState() 来更新。
我们可以把两者结合起来，使 React 的 state 成为“唯一数据源”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”。
例如，如果我们想让前一个示例在提交时打印出名称，我们可以将表单写为受控组件：
class NameForm extends React.Component { constructor(props) { super(props); this.state = {value: ''}; this.handleChange = this.handleChange.bind(this); this....</p></div><footer class=entry-footer><span title='2020-12-29 00:00:00 +0000 UTC'>December 29, 2020</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;494 words&nbsp;·&nbsp;子舒</footer><a class=entry-link aria-label="post link to React 学习笔记（三）" href=/blog/39.html/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>React －－万物皆可组件</h2></header><div class=entry-content><p>一、React 组件是什么？ 组件，从概念上类似于 javascript 函数，他接受任意入参（props），并返回作用于描述页面展示内容的 React 元素。
组件允许你将 UI 拆分为独立可复用的代码片段，并对每个片段进行独立构思。
1.创建一个组件 // 函数组件 function Welcome(props) { return &lt;h1>Hello, {props.name}&lt;/h1>; } // class组件 class Welcome extends React.Component { render() { return &lt;h1>Hello, {this.props.name}&lt;/h1>; } } 2.渲染组件 class Welcome extends React.Component { render() { return &lt;h1>Hello, {this.props.name}&lt;/h1>; } } ReactDOM.render( &lt;Welcome />, document.getElementById('root') ); 3.组件 React的基础原则有三条，分别是：
React 界面完全由数据驱动 React 中一切都是组件 props 是 React 组件之间通讯的基本方式 给组件输入一个参数，最终返回一个 React Element,React Element 就是在页面上展示的内容，相当于一个 DOM 节点
React 一大核心就是－－万物皆可组件...</p></div><footer class=entry-footer><span title='2020-12-21 00:00:00 +0000 UTC'>December 21, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;102 words&nbsp;·&nbsp;子舒</footer><a class=entry-link aria-label="post link to React －－万物皆可组件" href=/blog/37.html/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>javascript 进阶问题</h2></header><div class=entry-content><p>Github：https://github.com/lydiahallie/javascript-questions
相当不错的一个 Github 仓库，javascript questions ，作者每周都会发布一些有关 javascript 的题目，虽然不难但是考察细节，刷了一会，其实一些很简单的问题，结果因为细节思考不到位直接出错。
引用作者的话：我在我的 Instagram 上每天都会发布 JavaScript 的多选问题，并且同时也会在这个仓库中发布。
从基础到进阶，测试你有多了解 JavaScript，刷新你的知识，或者帮助你的 coding 面试！</p></div><footer class=entry-footer><span title='2020-12-19 00:00:00 +0000 UTC'>December 19, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;17 words&nbsp;·&nbsp;子舒</footer><a class=entry-link aria-label="post link to javascript 进阶问题" href=/blog/36.html/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>React 学习笔记（二）</h2></header><div class=entry-content><p>React 元素的事件处理和 DOM 元素的很相似，但是有一点语法上的不同
React 事件的命名采用小驼峰式（camelCase），而不是纯小写
使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串
一、事件处理 1.事件绑定 React 元素的事件处理和 DOM 元素类似，但是在语法上有些区别，比如：
传统的html：用双引号包裹，后面必须跟参数
&lt;button onclick="myfun()">点击&lt;/button> React：用大括号包裹，后面不跟参数
&lt;button onclick={myfun}>点击&lt;/button> 一个完整的事件函数代码如下
class Demo extends React.Component { render() { // 事件函数 function myfun() { alert('helo,world') } return ( // 绑定事件 &lt;button onClick={this.myfun}> Activate Lasers &lt;/button> ) } } ReactDOM.render( &lt;Demo />, document.getElementById('root') ) 如果方法后面没有()，则需要为这个方法绑定 this
2.阻止默认行为 在 React 中还有一个不同的点，不能通过返回 fasle 阻止默认行为， React 提供了一个属性－－preventDefault，可以通过 preventDefault 阻止脚本执行
看一下传统的 html 和 React 的对比...</p></div><footer class=entry-footer><span title='2020-12-16 00:00:00 +0000 UTC'>December 16, 2020</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1581 words&nbsp;·&nbsp;子舒</footer><a class=entry-link aria-label="post link to React 学习笔记（二）" href=/blog/35.html/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>React 中的占位符 Fragment</h2></header><div class=entry-content><p>在 React 项目中， render 方法只能有一个根元素，一般都是 &lt;div> &lt;div/> ，然后在里面写上我们的组件，渲染到浏览器一看，除了我们想要显示的组件，外面还套着一层 div ，如果在写项目的时候，套了很多曾组件，那么每一层都会多出来一个父级元素 div ，不美观，而且在调整样式的时候会有些麻烦
因此， React 提供了一个占位符 Fragment，写法是：
// index.js import React, { Component,Fragment } from 'react' export default class index extends Component { render() { return ( &lt;Fragment> &lt;h2>hello,wolrd&lt;/h2> &lt;/Fragment> ) } } 在引入 React 的时候，增加一个属性 Fragment ，然后 render()方法下唯一的根元素我们用 &lt;Fragment> &lt;/Fragment> 来代替，这时候再看浏览器，就不会显示多余的标签了，直接显示 &lt;h2>标签</p></div><footer class=entry-footer><span title='2020-12-12 00:00:00 +0000 UTC'>December 12, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;52 words&nbsp;·&nbsp;子舒</footer><a class=entry-link aria-label="post link to React 中的占位符 Fragment" href=/blog/33.html/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=/categories/%E6%8A%80%E6%9C%AF/page/11/>«&nbsp;Prev&nbsp;</a>
<a class=next href=/categories/%E6%8A%80%E6%9C%AF/page/13/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2023 <a href=/>子舒的博客</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>