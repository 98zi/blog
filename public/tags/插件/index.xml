<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>插件 on 子舒的博客</title>
    <link>https://zishu.me/tags/%E6%8F%92%E4%BB%B6/</link>
    <description>Recent content in 插件 on 子舒的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 23 Jan 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://zishu.me/tags/%E6%8F%92%E4%BB%B6/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>分析 VScode 中 Live Server 插件</title>
      <link>https://zishu.me/blog/217.html/</link>
      <pubDate>Tue, 23 Jan 2024 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/217.html/</guid>
      <description>在 VScode 中运行 Live Server 插件时，会默认给网页添加一串 js 代码，用于实现浏览器的实时重新加载（live reloading）功能，通过WebSocket与服务器进行通信。 if (&amp;#39;WebSocket&amp;#39; in window) { (function () { function refreshCSS() { var sheets = [].slice.call(document.getElementsByTagName(&amp;#34;link&amp;#34;)); var head = document.getElementsByTagName(&amp;#34;head&amp;#34;)[0]; for (var i = 0; i &amp;lt; sheets.length; ++i) { var elem = sheets[i]; var parent = elem.parentElement || head; parent.removeChild(elem); var rel = elem.rel; if (elem.href &amp;amp;&amp;amp; typeof rel != &amp;#34;string&amp;#34; || rel.length == 0 || rel.toLowerCase() == &amp;#34;stylesheet&amp;#34;) { var url = elem.href.replace(/(&amp;amp;|\?)_cacheOverride=\d+/, &amp;#39;&amp;#39;); elem.href = url + (url.indexOf(&amp;#39;?&amp;#39;) &amp;gt;= 0 ? &amp;#39;&amp;amp;&amp;#39; : &amp;#39;?&amp;#39;) + &amp;#39;_cacheOverride=&amp;#39; + (new Date().valueOf()); } parent.appendChild(elem); } } var protocol = window.location.protocol === &amp;#39;http:&amp;#39; ? &amp;#39;ws://&amp;#39; : &amp;#39;wss://&amp;#39;; var address = protocol + window.location.host + window.location.pathname + &amp;#39;/ws&amp;#39;; var socket = new WebSocket(address); socket.onmessage = function (msg) { if (msg.data == &amp;#39;reload&amp;#39;) window.location.reload(); else if (msg.data == &amp;#39;refreshcss&amp;#39;) refreshCSS(); }; if (sessionStorage &amp;amp;&amp;amp; !sessionStorage.getItem(&amp;#39;IsThisFirstTime_Log_From_LiveServer&amp;#39;)) { console.log(&amp;#39;Live reload enabled.&amp;#39;); sessionStorage.setItem(&amp;#39;IsThisFirstTime_Log_From_LiveServer&amp;#39;, true); } })(); } else { console.error(&amp;#39;Upgrade your browser. This Browser is NOT supported WebSocket for Live - Reloading.&amp;#39;); } 1.首先判断浏览器是否支持 WebSocket if (&amp;#39;WebSocket&amp;#39; in window) 这个条件语句检查浏览器是否支持 WebSocket。如果支持，就执行后续的代码块，否则输出错误信息并停止执行。 2.定义refreshCSS函数 function refreshCSS() { // ... } 这个函数用于刷新页面上的css。它会遍历页面上所有的 &amp;lt;link&amp;gt; 标签，移除它们，然后再次添加，触发css的重新加载。 3.构建WebSocket连接 var protocol = window.location.protocol === &amp;#39;http:&amp;#39; ? &amp;#39;ws://&amp;#39; : &amp;#39;wss://&amp;#39;; var address = protocol + window.location.host + window.location.pathname + &amp;#39;/ws&amp;#39;; var socket = new WebSocket(address); 这部分代码根据当前页面的协议（HTTP或HTTPS）构建WebSocket的连接地址，然后创建一个WebSocket对象，连接到这个地址。 4.WebSocket消息处理 socket.onmessage = function (msg) { if (msg.data == &amp;#39;reload&amp;#39;) window.location.reload(); else if (msg.data == &amp;#39;refreshcss&amp;#39;) refreshCSS(); }; 当WebSocket接收到消息时，会执行这个回调函数。如果消息是 &amp;lsquo;reload&amp;rsquo;，则刷新整个页面；如果消息是 &amp;lsquo;refreshcss&amp;rsquo;，则调用refreshCSS函数刷新CSS。 5.检测是否执行成功 通过判断 sessionStorage &amp;amp;&amp;amp; !sessionStorage.getItem(&#39;IsThisFirstTime_Log_From_LiveServer&#39;) 属性监测前面的代码是否运行成功，并返回一定的提示，这里可以在前端用于进行标记，并且只会在WebSocket链接成功时返回，如果时更新数据不会重复运行。 if (sessionStorage &amp;amp;&amp;amp; !sessionStorage.getItem(&amp;#39;IsThisFirstTime_Log_From_LiveServer&amp;#39;))</description>
    </item>
    <item>
      <title>实现图片灯箱功能</title>
      <link>https://zishu.me/blog/88.html/</link>
      <pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate>
      <guid>https://zishu.me/blog/88.html/</guid>
      <description>写博客必不可少的一个功能就是图片灯箱功能，也就是点击放大查看。但是不同程序的博客所使用的插件也都不一样，我这里研究出一套可以满足绝大部分程序的灯箱插件。已经测试过 hexo, hugo, typecho 均无问题。 引入文件 首先引入我们关键的两个文件分别是 zoom.css 和 zoom.js 。 &amp;lt;!-- head 头部 --&amp;gt; &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;https://cdn.zburu.com/list/zoom.css&amp;#34;&amp;gt; &amp;lt;!-- body 底部 --&amp;gt; &amp;lt;!-- 如果已经有 jq 文件了，就不要引入 jquery --&amp;gt; &amp;lt;script src=&amp;#34;https://cdn.zburu.com/list/jquery3.6.0.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;!--图片灯箱--&amp;gt; &amp;lt;img src=&amp;#34;&amp;#34; alt=&amp;#34;&amp;#34; class=&amp;#34;bigimg&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;mask&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script src=&amp;#34;https://cdn.zburu.com/list/zoom.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; 因为这个文件是放在我自己服务器上的，所以不敢保证以后还是这个路径，建议在浏览器打开，然后把里面的代码复制到本地使用。 调用 js 然后我们需要给图片一个类名，以及一个父元素盒子，同样也可以使用 jq 来完成。 这里的 .post-content 正文的类名，如果你是别的类名，可以直接将 .post-content 替换掉。 $(function(){ $(&amp;#39;.post-content img&amp;#39;).addClass(&amp;#39;smallimg&amp;#39;) $(&amp;#39;.post-content img&amp;#39;).wrap(&amp;#39;&amp;lt;div class=&amp;#34;imgbox&amp;#34;&amp;gt;&amp;lt;/div&amp;gt;&amp;#39;) }) 接着我们需要对插件进行初始化，直接在刚才的代码下面写入。 $(function(){ $(&amp;#39;.post-content img&amp;#39;).addClass(&amp;#39;smallimg&amp;#39;) $(&amp;#39;.post-content img&amp;#39;).wrap(&amp;#39;&amp;lt;div class=&amp;#34;imgbox&amp;#34;&amp;gt;&amp;lt;/div&amp;gt;&amp;#39;) /* smallimg // 小图 bigimg //点击放大的图片 mask //黑色遮罩 */ var obj = new zoom(&amp;#39;mask&amp;#39;, &amp;#39;bigimg&amp;#39;, &amp;#39;smallimg&amp;#39;); obj.init(); }) 回到页面上，点击正文的图片就可以成功放大了。 结束 随便放个图片试验一下吧！ 之所以我限制了在正文中才可以放大，是因为网站其他地方也有图片，如果都可以点击放大，就很不合理。 如果在使用中有其他问题，欢迎留言。</description>
    </item>
  </channel>
</rss>
