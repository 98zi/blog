<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>笔记 | 子舒的博客</title><meta name=keywords content><meta name=description content="子舒的博客，记录生活"><meta name=author content="子舒"><link rel=canonical href=/tags/%E7%AC%94%E8%AE%B0/><link crossorigin=anonymous href=/assets/css/stylesheet.5ea1a2f851c645871793276dce298322e6dbf894e6328ec3a0b36446942b7f71.css integrity="sha256-XqGi+FHGRYcXkydtzimDIubb+JTmMo7DoLNkRpQrf3E=" rel="preload stylesheet" as=style><link rel=icon href=https://img.zburu.com/favicon.ico><link rel=mask-icon href=/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=/tags/%E7%AC%94%E8%AE%B0/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="笔记"><meta property="og:description" content="子舒的博客，记录生活"><meta property="og:type" content="website"><meta property="og:url" content="/tags/%E7%AC%94%E8%AE%B0/"><meta property="og:image" content="/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="笔记"><meta name=twitter:description content="子舒的博客，记录生活"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=/ accesskey=h title="子舒的博客 (Alt + H)">子舒的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=/categories/ title=categories><span>categories</span></a></li><li><a href=/message/ title=message><span>message</span></a></li><li><a href=/lab/ title=lab><span>lab</span></a></li><li><a href=/about/ title=about><span>about</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>笔记
<a href=/tags/%E7%AC%94%E8%AE%B0/index.xml title=RSS aria-label=RSS><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2>笔记:vue 中使用 axios 调用数据并渲染</h2></header><div class=entry-content><p>示例如下。
&lt;template> &lt;div class="posts"> &lt;div v-for="item in list" :key="item.cid" > {{ item.title }} &lt;/div> &lt;/div> &lt;/template> &lt;script> import Axios from 'axios'; export default { name: 'index', data () { return { list: [] } }, methods: { getData () { var api = 'https://zburu.com/api/posts.php'; Axios.get(api).then((response) => { this.list = response.data; console.log(response.data) }).catch((error) => { console.log(error); }) } }, mounted () { this.getData(); }, } &lt;/script> &lt;style> &lt;/style></p></div><footer class=entry-footer><span title='2022-07-12 00:00:00 +0000 UTC'>July 12, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;67 words&nbsp;·&nbsp;子舒</footer><a class=entry-link aria-label="post link to 笔记:vue 中使用 axios 调用数据并渲染" href=/blog/151.html/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>obsidian:如何使用坚果云进行多端同步?</h2></header><div class=entry-content><p>接上篇文章 《关于我选择笔记系统这件小事》 ，obsidian 的个人体验很棒，我也打算长久使用作为个人知识库。
但是它有一个弊端，就是本地离线化导致同步是个问题，官方的同步服务很贵，给我劝退了，因此我寻求了其他的同步备份方案，就是今天我要分享的坚果云+ obsidian 。
注册账号 在坚果云官网注册一个账号，选择个人用户，创建账号之后登陆。
点击创建 > 个人同步文件夹，以后就同步这个文件夹内的内容了。这个我在里面新建了一个 test 文件夹。
pc端同步 接下来需要将电脑本地的文件和坚果云的文件夹相连接，只要你在本地修改了文件，自动同步到坚果云。
点击页面左侧的下载客户端。
下载完成之后登陆，你就可以看到里面有一个 test 文件夹，是刚才在网页官网创建的。然后在右边三个点里面选择同步到本地。
浏览你的文件夹，找到一个地方存放 test 文件夹，点击确定，坚果云就会自动同步你在本地文件。但是这个时候 test 文件夹是空的，需要将 obsidian 文件全部移动进去就行了。然后在 obsidian 客户端重新打开 test 库。
在另一台电脑，进行上面同样的操作，将坚果云的同步文件夹映射到本地，就会自动下载云端的文件。之后，不管你在哪台电脑修改 obsidian 笔记，都会同步到拥有坚果云客户端的其他电脑。
这是 pc 端同步的方案，之后我会继续分享如果将 pc 同步到手机端。</p></div><footer class=entry-footer><span title='2022-06-27 00:00:00 +0000 UTC'>June 27, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;39 words&nbsp;·&nbsp;子舒</footer><a class=entry-link aria-label="post link to obsidian:如何使用坚果云进行多端同步?" href=/blog/146.html/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>关于我选择笔记系统这件小事</h2></header><div class=entry-content><p>受年龄增长以及生活影响，人接触到的新事物和知识将会越来越多，大脑就显得有些混乱了，我也不敢保证自己的思维会始终保持一个高强度的在线状态。
因此决定整理个人知识库， 将大脑中的片段和思想整理出来。以笔记和文字的形式将他记录下来，但是最近一直在寻求这样的工具，多方对比，也没有一款能真正满足我的需求的工具。
最好是自建的笔记，因为我今天在语雀写了一篇私密笔记，或许因为内容略带敏感吧，然后就被审查了，说我违规。
语雀这是我目前最满意的工具，但是现在对他的热情瞬间降低了很多。我怕哪天一下子账号里面的笔记全部被删了，那样我会很绝望的。
接下来我还会多方对比，最终选择一款平台亦或者是自建的笔记系统。
博客是写给别人看的，笔记是给自己看的，包括一些计划，列表清单等等，都是隐私的内容。还有就是一些文章的草稿，碎片化的记录，所以不宜放在博客上。
而且对于功能方面，我也有较高的要求，比如拖拽，表单，下拉框，卡片等等，都是我比较需要的，隐私和安全性更是我比较看重的。
暂时就这样吧，我会慢慢寻觅。
2022/05/03 更新
经过为期一周的尝试和部署过后，我最终决定了使用思源笔记，可以使用docker进行私有部署，本地备份，而且还可以选择付费订阅，备份到官方，这是两种可以同时进行的选择，我觉得很好的满足了我的需要。
主要还是思源的功能以及外表打动了我，页面简洁而美，功能不臃肿，刚好我需要的他都有，一点也没有多余的按键。符合我对笔记和个人知识库的个人，支持双链，不过我暂时用不到。支持markdown格式导入导出。
而我也逐步将我其他的笔记都迁移过来了，不过目前唯一的缺陷好像不支持分享，这也算我某种需求吧，我在寻求其解决方案，不过也不算什么大问题。
思源很多细节都打动了我，在单个文章复制的时候，提供了直接复制到其他平台的格式，不用再手动调了。
至于安全性方面，可以设置全局鉴权密码，不支持单篇文章加密。
2022/05/18 更新
半个月过去了，慢慢从思源迁移出来，原因很多，一方面是针对文件的安全性和稳定性抱有一丝怀疑，另外就是同步的问题，成本和精力都有些费事。
因此我选择了一个更不错的软件—obsidian，强大的社区，海量的插件以及可扩展性都是我选择它的原因。
对比之下，它更像是笔记界的vscode，优势很多，轻量，可扩展，插件多。同时使用坚果云进行多端同步，这样不论是在公司电脑还是在自己的电脑上，我都可以做到无缝切换。
2022/06/18 更新
使用了一个月的 obsidain，反馈一下感受。整体来说很适合我这种记录文字的人，对 markdown 语法支持特别友好，格式都可以根据自己的想法展示出来，还带有一些插件，扩展我的使用方法。
在安全性方面，本地化、离线化也是非常棒的，可以根据自己的需要利用同步盘进行同步，或者自建 webdav 服务，稳定性也是很高的。
在数据迁移方面，完全不用担心，数据本质上还是 markdown 文件，如果哪有你对 obsidian 失望不再使用，或者有了更好的选择，可以直接把文件夹复制过去，都是很方便的。
但是这也只针对纯文件来说，如果是元数据，带有一些属性类的东西时，obsidain 就不是很好的选择了。正因为它是一个纯文件，所以注定没法保存元数据信息，这方面我和群里的阿均作了深刻的探讨。他比较注重 “属性，标签，双链的指向，关系链，数值大小，层级隶属” 等概念。
obsidian 是一堆小文件集合在一起形成的笔记架构，这和一般的数据库不太一样。
小文件很难做数据管理，反正长期看性能方面会有问题。一致性，也有问题，不重新索引确保不了一致性，重新索引，对于海量小文件，又难以提高性能。
阿均的担忧我也是能理解的，不过我们对笔记的定位有所不同。他更希望打造一个碎片化，利用双链结构形成自己的知识架构；而我是需要一个类 wiki 的东西，将我所获取到的知识按照分类进行归档，然后根据关键词，标签，标题，正文等内容进行搜索查询。
这是不同的方向，所以选择了不同的软件也是很正常的。</p></div><footer class=entry-footer><span title='2022-04-28 00:00:00 +0000 UTC'>April 28, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;46 words&nbsp;·&nbsp;子舒</footer><a class=entry-link aria-label="post link to 关于我选择笔记系统这件小事" href=/blog/121.html/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>【笔记】使用php写接口文件调用数据</h2></header><div class=entry-content><p>如何使用 php 写一个接口，然后将数据以 json 文件格式调用。
&lt;?php header('Content-Type:application/json; charset=utf-8'); header("Access-Control-Allow-Origin:*"); $servername = "localhost"; $username = "数据库账号"; $password = "数据库密码"; $dbname = "数据库名称"; // 创建连接 $conn = new mysqli($servername, $username, $password, $dbname); // 检测连接 if ($conn->connect_error) { die("连接失败: " . $conn->connect_error); } $sql = "select slug,title,created,text from typecho_contents"; $result = $conn->query($sql); if ($result->num_rows > 0) { // 输出数据 while($row = $result->fetch_assoc()) { $data[]=$row; } $json = json_encode($data,JSON_UNESCAPED_UNICODE|JSON_PRETTY_PRINT);//把数据转换为JSON数据. exit($json) ; } else { echo "未查询到结果！"; } $conn->close(); ?...</p></div><footer class=entry-footer><span title='2022-02-22 00:00:00 +0000 UTC'>February 22, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;88 words&nbsp;·&nbsp;子舒</footer><a class=entry-link aria-label="post link to 【笔记】使用php写接口文件调用数据" href=/blog/103.html/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>我的 python 学习笔记</h2></header><div class=entry-content><p>之所以学习 Python ，本意是想写一些脚本之类的程序，用来在浏览器爬一些自己想要的文字，图片等资料，这些程序其实 GitHub 蛮多的，但奈何我对后端的语言一窍不通，直接拿过来给我用我都不会。
因此就萌生了先学习 Python 基础知识的想法，一直听说廖雪峰的 Python 教程写的不错，这次趁着这个机会要好好研读一番。也没想说用的多牛逼，至少希望能为自己浅薄的技术栈再增加一点光彩，毕竟我也曾梦想成为一个全栈开发。
下载安装完 Python 环境,就开始学习吧！
运行我的第一个python程序 print('hello,world') 数据类型 在 Python 中，能直接处理的数据类型有几种，整数、浮点数、字符串、布尔值、空值、变量。
这与其他语言其实差别并不大，数据类型基本都是相似的，大概只有变量有自己的特性，所以我单独拿出来记录一下。
变量 python 是一门动态语言，在赋值时可以不断改变，比如：
a = 123 print(a) # 终端输出数值 123 a = 'abc' print(a) # 终端输出字符串 abc 这是允许的，而在 Java 中则不行，它是一门静态语言，如果多次赋值会报错。相对来说，动态语言更灵活，当然，各有利弊罢了。
并且在赋值上面有一个逻辑顺序，比如定义一个 a = 'a' 的变量。在 Python 中其实走了两步，先创造了一个字符串 a ，然后将这个字符串赋值给变量 a 。
其实这在数学上是有些反逻辑的，x = x + 2 这个计算是行不通的在数学上，但是在计算机中，先计算 x + 2 ，然后将其赋值给左侧的 x ，这是计算机的逻辑。
x = 1 x = x + 2 print(x) # 3 其实很多计算机语言都是如此，比如我们所熟知的 js 等等。...</p></div><footer class=entry-footer><span title='2021-04-01 00:00:00 +0000 UTC'>April 1, 2021</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;234 words&nbsp;·&nbsp;子舒</footer><a class=entry-link aria-label="post link to 我的 python 学习笔记" href=/blog/61.html/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>React 学习笔记（三）</h2></header><div class=entry-content><p>来源于：https://react.docschina.org/docs/forms.html
一、表单 在 React 中，html 表单元素的工作方式和其他的 DOM 元素不太一样，因为表单内部通常会保持一些内部的 state，比如下面这个纯 html 表单只接受一个名称：
&lt;form> &lt;label> 名字: &lt;input type="text" name="name" /> &lt;/label> &lt;input type="submit" value="提交" /> &lt;/form> 这个表单具有默认的 html 表单行为，即在用户提交表单之后自动刷新页面。如果你在 React 中执行相同的代码，它仍然有效。
但大多数情况下，使用 JavaScript 函数可以很方便的处理表单的提交， 同时还可以访问用户填写的表单数据。实现这种效果的标准方式是使用“受控组件”。
受控组件 在 html 中，表单元素比如&lt;input>，&lt;textarea>，&lt;select>，这些表单元素通常自己维护 state，并根据用户输入进行更新。而在 React 中，可变状态（mutable state）通常保存在组件的 state 属性中，并且只能通过使用 setState() 来更新。
我们可以把两者结合起来，使 React 的 state 成为“唯一数据源”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”。
例如，如果我们想让前一个示例在提交时打印出名称，我们可以将表单写为受控组件：
class NameForm extends React.Component { constructor(props) { super(props); this.state = {value: ''}; this.handleChange = this.handleChange.bind(this); this....</p></div><footer class=entry-footer><span title='2020-12-29 00:00:00 +0000 UTC'>December 29, 2020</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;494 words&nbsp;·&nbsp;子舒</footer><a class=entry-link aria-label="post link to React 学习笔记（三）" href=/blog/39.html/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>vue学习笔记(3)－－computed, watch，calss, style</h2></header><div class=entry-content><p>一、计算属性computed 1.例子 &lt;div id="app"> &lt;div>{{message}}&lt;/div> &lt;div>{{revermessage}}&lt;/div> &lt;/div> &lt;script> var vm = new Vue({ el: '#app', data: { message: 'hello,wolrd' }, computed: { revermessage: function() { return this.message.split('').reverse().join('') } } }) &lt;/script> 声明一个计算属性severmessage，在computed中被指向对message进行一些方法操作后的返回值
此时vm.severmessage依赖于vm.message的变化，对message改变数据，会引起severmessage的更新
2.计算属性缓存和方法 还可以通过在表达式中调用方法来达到想要的效果
&lt;div id="app"> &lt;div>{{message}}&lt;/div> &lt;div>{{revermessage()}}&lt;/div> &lt;/div> &lt;script> var vm = new Vue({ el: '#app', data: { message: 'hello,wolrd' }, methods: { revermessage: function() { return this.message.split('').reverse().join('') } } }) &lt;/script> 经过测试，两者的结果是一样的
我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的
区别是：计算属性是基于他们的响应式依赖进行缓存的，只有当响应式依赖，也就是message发生改变时才会重新求值，就意味着，只要message还没改变，多次访问revermessage计算属性只会返回之前计算结果的缓存，而不是直接执行计算属性的函数
而方法，在每次触发重新渲染时，调用方法都会执行一次函数，这就多了一份开销
我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用方法来替代...</p></div><footer class=entry-footer><span title='2020-11-25 00:00:00 +0000 UTC'>November 25, 2020</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;371 words&nbsp;·&nbsp;子舒</footer><a class=entry-link aria-label="post link to vue学习笔记(3)－－computed, watch，calss, style" href=/blog/29.html/></a></article><footer class=page-footer><nav class=pagination><a class=next href=/tags/%E7%AC%94%E8%AE%B0/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2023 <a href=/>子舒的博客</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>