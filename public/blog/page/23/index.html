<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Blogs | 子舒的博客</title><meta name=keywords content><meta name=description content="Blogs - 子舒的博客"><meta name=author content="子舒"><link rel=canonical href=/blog/><link crossorigin=anonymous href=/assets/css/stylesheet.5ea1a2f851c645871793276dce298322e6dbf894e6328ec3a0b36446942b7f71.css integrity="sha256-XqGi+FHGRYcXkydtzimDIubb+JTmMo7DoLNkRpQrf3E=" rel="preload stylesheet" as=style><link rel=icon href=https://img.zburu.com/favicon.ico><link rel=mask-icon href=/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=/blog/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Blogs"><meta property="og:description" content="子舒的博客，记录生活"><meta property="og:type" content="website"><meta property="og:url" content="/blog/"><meta property="og:image" content="/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Blogs"><meta name=twitter:description content="子舒的博客，记录生活"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"/blog/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=/ accesskey=h title="子舒的博客 (Alt + H)">子舒的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=/categories/ title=categories><span>categories</span></a></li><li><a href=/message/ title=message><span>message</span></a></li><li><a href=/lab/ title=lab><span>lab</span></a></li><li><a href=/about/ title=about><span>about</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>Blogs
<a href=/blog/index.xml title=RSS aria-label=RSS><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><header class=entry-header><h2>react学习路径－－怎么学习react？</h2></header><div class=entry-content><p>转载于:https://github.com/petehunt/react-howto，react开源作者对于react框架的一个学习路径的建议，个人感觉还是相当不错的学习路线
如何学习React? 如果你是一个 React (或者前端) 新手, 出于以下的原因, 你可能会对这个生态圈感到困惑:
React 的目标群体历来是喜欢尝试新事物的开发者和前端专家. Facebook 开源的内容是应用在他们的实际应用中, 因此他们没有关注那些比 Facebook 小的工程需求. 现有的 React 指引水平参差不齐. 在本文中, 我会假设你已有使用 HTML, CSS 和 JavaScript 开发网页的基础.
为什么要听我的? 关于 React, 现在已经有大量的相互冲突的建议了, 为什么要听我的?
因为我是在 Facebook 构建并开源 React 的最初成员之一. 现在我离开了 Facebook 并加入了一家初创公司, 所以我也不会站在 Facebook 的立场上来表态.
如何踏入 React 生态圈 所有的软件都是建立在某个技术栈之上的, 你需要对整个技术栈有足够深入的理解, 才能建造你的应用. 为什么 React 生态圈的工具似乎总让人感觉压力山大呢, 因为它总是以错误的顺序被解释:
你应该按照以下的顺序进行学习, 而不是跳着学或者同时学习:
React npm JavaScript “打包工具” ES6 Routing Flux 你不需要把这些都学完才去使用 React. 只需要在你遇到问题需要解决的时候, 才进入下一步的学习.
另外, 在 React 社区中, 有一些前沿主题是经常被提及到的, 以下的这些主题很有意思, 但也很难弄懂, 所以它们远没有上面的主题流行, 大多数应用也不需要用到这些....</p></div><footer class=entry-footer><span title='2020-11-19 00:00:00 +0000 UTC'>November 19, 2020</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;460 words&nbsp;·&nbsp;子舒</footer><a class=entry-link aria-label="post link to react学习路径－－怎么学习react？" href=/blog/23.html/></a></article><article class=post-entry><header class=entry-header><h2>在js中运算不能随便把value属性定义成变量</h2></header><div class=entry-content><p>在写一个小demo的时候，无意中发现定义变量的时候直接写入value，会导致获取不到数据，或者获取的不是我们想要的内容，在js中运算不能随便把value属性定义成变量
先看一段代码
&lt;input type="text"" id="a"> &lt;span>*&lt;/span> &lt;input type="text" id="b"> &lt;input type="button" value="=" onclick="beto()"> &lt;input type="text" id="sub" disabled> &lt;script> function beto() { var a = document.getElementById('a').value var b = document.getElementById('b').value var sub = document.getElementById('sub').value sub = a + b } &lt;/script> 就这么一看，逻辑貌似没有问题，获取a和b的value，乘法运算，然后输出sub
但是放在浏览器运行的时候，发现完全没有反应
为什么呢？
（假装思考五分钟…）
因为sub.value不能直接定义在变量中
// 先定义id为sub的input框 var sub = document.getElementById('sub') // 然后在运算的时候在直接使用sub.value sub.value = a * b 顺手放一个写demo时候用的简易计算器
&lt;!DOCTYPE html> &lt;html lang="en"> &lt;head> &lt;meta charset="UTF-8"> &lt;title>简易计算器&lt;/title> &lt;/head> &lt;body> &lt;input type="text"" id="a"> &lt;select id="c"> &lt;option value="+">+&lt;/option> &lt;option value="-">-&lt;/option> &lt;option value="*">*&lt;/option> &lt;option value="/">/&lt;/option> &lt;/select> &lt;input type="text" id="b"> &lt;input type="button" value="=" onclick="beto()"> &lt;input type="text" id="sub" disabled> &lt;script> function beto() { var a = document....</p></div><footer class=entry-footer><span title='2020-11-18 00:00:00 +0000 UTC'>November 18, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;153 words&nbsp;·&nbsp;子舒</footer><a class=entry-link aria-label="post link to 在js中运算不能随便把value属性定义成变量" href=/blog/22.html/></a></article><article class=post-entry><header class=entry-header><h2>事件监听函数，以及事件的捕获和冒泡机制</h2></header><div class=entry-content><p>事件一般是用于浏览器和用户操作之间的交互，当用户执行某些特殊的操作时，浏览器给予反应，触发绑定的事件，事件流，事件发生时会在元素节点和根节点之间按照约定的顺序传播，事件经过的所有节点都会受到事件的影响，这个传播过程被称为DOM事件流
函数事件 事件一般是用于浏览器和用户操作之间的交互，当用户执行某些特殊的操作时，浏览器给予反应，触发绑定的事件
事件流，事件发生时会在元素节点和根节点之间按照约定的顺序传播，事件经过的所有节点都会受到事件的影响，这个传播过程被称为DOM事件流
true是捕获，false是冒泡，默认为冒泡事件
1.addEventListener()－－添加事件监听函数 给元素添加一个事件，假如有多个事件，不会覆盖，会依次执行
&lt;div id="demo">dom&lt;/div> &lt;script> document.getElementById('demo').addEventListener("click", myfun) document.getElementById('demo').addEventListener("click", myfun1) function myfun() { console.log('事件监听函数') } function myfun1() { console.log('addEventListener') } &lt;/script> 注意： 1.这里有一个细节，addEventListener()里面有两个参数，第一个表示触发的条件，第二个表示触发的事件 正常情况下，第二个参数直接写函数名并且不加参数()，如果加了参数()则表示立即执行，不需要触发第一个参数要求的条件
2.在这里绑定事件的时候，事件名不能和定义的变量名一样，否则无效
2.removeEventListener()－－移除事件监听函数 下面这个demo，当鼠标在div中移动的时候，出现随机数，点击按钮后，移除事件监听函数
&lt;!-- css --> &lt;style> #demo { width: 100px; height: 100px; border: 1px solid #000; } &lt;/style> &lt;!-- html --> &lt;div id="demo">&lt;/div> &lt;input type="button" value="点击移除" onclick="remove()"> &lt;div id="show">&lt;/div> &lt;!-- js --> &lt;script> document.getElementById('demo').addEventListener("mousemove", myfun) function myfun() { document.getElementById('show').innerHTML = Math.random() } function remove() { document....</p></div><footer class=entry-footer><span title='2020-11-17 00:00:00 +0000 UTC'>November 17, 2020</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;299 words&nbsp;·&nbsp;子舒</footer><a class=entry-link aria-label="post link to 事件监听函数，以及事件的捕获和冒泡机制" href=/blog/21.html/></a></article><article class=post-entry><header class=entry-header><h2>getElementBy系列和querySelector系列的区别</h2></header><div class=entry-content><p>querySelector和querySelectorAll的用法和getElementBy大致一样，获取的时候带上符号，getElementBy获取的是元素的动态集合，querySelector获取的是元素的静态集合。
但是需要注意：getElementBy系列和querySelector系列的区别
比如，我们写一个for循环，每次获取li标签的时候，ul生成一个li子元素
&lt;ul id="ul"> &lt;li>a&lt;/li> &lt;li>b&lt;/li> &lt;li>c&lt;/li> &lt;/ul> &lt;script> var ul = document.getElementById('ul'); var li = document.getElementsByTagName('li'); for(var i = 0;i &lt; li.length; i++) { ul.appendChild(document.createElement('li')) }; console.log(li.length); // 陷入死循环 &lt;/script> 用i &lt; li.length来进行判断时，会导致浏览器死循环，因为循环一次的时候，浏览器又重新获取li标签数组，每调用一次就会重新对文档进行查询，就会进入死循环
进行修改：把i &lt; li.length改成i &lt; 3，把li标签数组静态化，然后打印
conosle.log(li.length) // 6 重新用querySelector获取一遍元素
&lt;ul id="ul"> &lt;li>a&lt;/li> &lt;li>b&lt;/li> &lt;li>c&lt;/li> &lt;/ul> &lt;script> var ul = document.querySelector('ul'); var li = document.querySelectorAll('li'); for(var i = 0;i&lt;li.length;i++) { ul.appendChild(document.createElement('li')) }; console.log(li.length); // 输出对结果是原来的li.length = 3，而不是增加后的 6 &lt;/script> 静态集合体现在querySelectorAll('li')获取到ul里所有li后，不管后续再动态添加了多少li，都是不会对其参数影响</p></div><footer class=entry-footer><span title='2020-11-16 00:00:00 +0000 UTC'>November 16, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;74 words&nbsp;·&nbsp;子舒</footer><a class=entry-link aria-label="post link to getElementBy系列和querySelector系列的区别" href=/blog/19.html/></a></article><article class=post-entry><header class=entry-header><h2>DOM－－文档对象模型</h2></header><div class=entry-content><p>DOM中文名文档对象模型，英文名Document Object Model，我们简称为DOM，是针对html和xml文档的一种API，将html以一种树状结构呈现出来，可以更直观去研究文档结构，我们将这种树状文档结构称为－－DOM树，或者节点树，一样的概念
一、什么是DOM？ DOM中文名文档对象模型，英文名Document Object Model，我们简称为DOM，是针对html和xml文档的一种API，将html以一种树状结构呈现出来，可以更直观去研究文档结构，我们将这种树状文档结构称为－－DOM树，或者节点树，一样的概念
js通过dom节点，可以对文档的html标签，属性，css样式，以及具体的内容做出修改，并对页面中的所有事件进行响应
二、节点树 1.节点类型 文档节点－－Document 标签节点－－Element 文本节点－－Text 注释节点－－Comment 属性节点－－Attr 2. 属性 节点类型－－nodeType 节点名称－－nodeName 节点值－－nodeValue 子节点－－childNodes 父节点－－parentNodes 上一个节点－－previousSibling 下一个节点－－nextSibling 第一个子节点－－firstChild 最后一个子节点－－lastChild 3.文档节点－－document (1) 获取 getElementById()－－通过id获取元素 &lt;div id="demo">通过id获取元素&lt;/div> &lt;script> var demo = document.getElementById('demo'); demo.onclick = function() { console.log('通过id获取元素') } &lt;/script> &lt;!-- 点击id为demo的元素，控制台输出'通过id获取元素' --> getElementsByName()－－通过name获取元素 &lt;input type="text" name="int" value="通过name获取元素1"> &lt;input type="text" name="int" value="通过name获取元素2"> &lt;script> var int = document.getElementsByName('int'); for(var i = 0;i &lt; int.length; i++) { console.log(int[i].value); } &lt;/script> &lt;!...</p></div><footer class=entry-footer><span title='2020-11-15 00:00:00 +0000 UTC'>November 15, 2020</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;772 words&nbsp;·&nbsp;子舒</footer><a class=entry-link aria-label="post link to DOM－－文档对象模型" href=/blog/18.html/></a></article><article class=post-entry><header class=entry-header><h2>有关js函数，方法的一些补充总结</h2></header><div class=entry-content><p>数据类型，构造函数，原型和原型链的一些讲解补充
一、数据类型 1.5个基本类型 string number boolean undefined 未定义 null 值为空 symbol 表示一个符号，符号类型是唯一的并且是不可修改的
最常见的还是前三种，字符串，数字，布尔值
2.常见的引用类型 引用类型是一种数据结构，用于将数据和功能组织在一起
对象－Object, 数组－Array, 函数－Function, 正则－RegExp, 日期－Date等
二、函数 1.什么是函数？ 具有独立功能的代码块，在js中使用function关键字定义函数 让代码结构更加清晰，提高代码可用性 js函数的分类：自定义函数和系统函数 2.自定义函数 有一种匿名函数，没有名字的函数，创建闭包，避免造成全局变量的污染
匿名自执行函数
概念：匿名函数的定义完成后立即执行，执行函数表达式 作用：实现闭包和创建独立的命名空间 使用：分组操作符()，void操作符，~操作符，!操作符等等 使用场景：函数表达式，对象属性，事件，事件参数，返回值 定义完匿名函数后，一定要调用 // 函数表达式 window.onload = function() { let funcobj = function() { alert("函数表达式中的匿名函数") } funcobj(); } // 对象属性 window.onload = function() { let obj = { name: function() { alert('对象属性中的匿名函数') } } obj.name(); } 3.内置函数 放在全局下面叫做函数，放在对象里面被叫做方法，对象的方法
常规函数 alert() // 弹出框 confirm() // 弹出一个确认框 prompt() // 弹出一个输入框 isNaN() // 判断是否为数字 parseInt() // 将字符串或浮点数转换为整数 parseFloat() // 将字符串转换为整数或浮点数 eval() // 计算表达式的结果 数组函数 用for循环遍历数组...</p></div><footer class=entry-footer><span title='2020-11-14 00:00:00 +0000 UTC'>November 14, 2020</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;465 words&nbsp;·&nbsp;子舒</footer><a class=entry-link aria-label="post link to 有关js函数，方法的一些补充总结" href=/blog/17.html/></a></article><article class=post-entry><header class=entry-header><h2>为什么getTime()返回1970年至今的毫秒？</h2></header><div class=entry-content><p>今天在写new Date()时候，无意中发现了一个很有意思的方法，getTime()，百度了一下，有人说是计算从1970年1月1日至今的毫秒数
为什么要是1970年呢？
new Date().getTime(); // xxxxxxxxxxx 这个起源于unix的诞生，因为Unix在1969年被开发出来，1971年正式发布，在这之前没有机器会需要来表示1970-01-01-00:00:00之前的时间，后面的语言很多就沿用了这一习惯，js只是也沿用了这种习惯而已。
当然，这一做法现在看来是很有问题的，例如不方便用它表示更早的时间而且精度有限。
定义time从1970年1月1日开始，忽然想到在JAVA里，Oracle数据库时间也是从1970年1月1日开始计算。
比如java类代码:
Date date = new Date(0); System.out.println(date); // 打印出来的结果：Thu Jan 01 08:00:00 CST 1970也 是1970年1月1日，实际上时分秒是0点0分0秒(这里打印出来是8点，稍后会作解释)。
为什么这个时间会定义在1970年1月1日这个时候呢?
于是开始了Google，中文网页根本找不到答案。于是试着搜索英文关键字,在Sun java论坛总算找到准确的帖子:
http://forums.sun.com/thread.jspa?threadID=595140&amp;start=15
其中有一个回复:
I suspect that Java was born and raised on a UNIX system. UNIX considers the epoch (when did time begin) to be midnight, January 1, 1970. 是说java起源于UNIX系统，而UNIX认为1970年1月1日0点是时间纪元.
但这依然没很好的解释"为什么",出于好奇，继续Google，总算找到了答案:
http://en.wikipedia.org/wiki/Unix_time
这里的解释是:
最初计算机操作系统是32位，而时间也是用32位表示。
System.out.println(Integer.MAX_VALUE);
2147483647
Integer在JAVA内用32位表示，因此32位能表示的最大值是2147483647。另外1年365天的总秒数是31536000，2147483647/31536000 = 68.1,也就是说32位能表示的最长时间是68年，而实际上到2038年01月19日03时14分07秒，便会到达最大时间，过了这个时间点，所有32位操作系统时间便会变为10000000 00000000 00000000 00000000也就是1901年12月13日20时45分52秒，这样便会出现时间回归的现象，很多软件便会运行异常了。
到这里，我想问题的答案已经出来了:...</p></div><footer class=entry-footer><span title='2020-11-13 00:00:00 +0000 UTC'>November 13, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;76 words&nbsp;·&nbsp;子舒</footer><a class=entry-link aria-label="post link to 为什么getTime()返回1970年至今的毫秒？" href=/blog/16.html/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=/blog/page/22/>«&nbsp;Prev&nbsp;</a>
<a class=next href=/blog/page/24/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2023 <a href=/>子舒的博客</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>