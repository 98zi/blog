<!DOCTYPE html>
<html lang="en-us">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Hugo 0.114.0">
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="toTop" content="true">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="author" content="" />
<meta property="og:url" content="https://zburu.com/blog/15.html/" />
<link rel="canonical" href="https://zburu.com/blog/15.html/" /><link rel="apple-touch-icon" href="https://img.zburu.com/favicon.png" />
<link rel="icon" href="https://img.zburu.com/favicon.png" />
<link rel="shortcut" href="https://img.zburu.com/favicon.png" /><link rel="alternate" type="application/atom+xml" href="https://zburu.com/index.xml" title="子舒的博客">
<script type="application/ld+json">
{
"@context" : "http://schema.org",
"@type" : "BlogPosting",
"mainEntityOfPage": {
"@type": "WebPage",
"@id": "https:\/\/zburu.com\/"
},
"articleSection" : "blog",
"name" : "面向对象编程",
"headline" : "面向对象编程",
"description" : "面向对象把构成问题的transaction分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为，意在写出通用代码，加强代码重用，屏蔽差异性。",
"inLanguage" : "en-US",
"author" : "子舒",
"creator" : "子舒",
"publisher": "子舒",
"accountablePerson" : "子舒",
"copyrightHolder" : "子舒",
"copyrightYear" : "2020",
"datePublished": "2020-11-12 12:58:00 \u002b0000 UTC",
"dateModified" : "2020-11-12 12:58:00 \u002b0000 UTC",
"url" : "https:\/\/zburu.com\/blog\/15.html\/",
"keywords" : [ "编程","js", ]
}
</script><title>面向对象编程@子舒</title>
<meta property="og:title" content="面向对象编程" />
<meta property="og:type" content="article" />
<meta property="og:description" content="面向对象把构成问题的transaction分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为，意在写出通用代码，加强代码重用，屏蔽差异性。" />
<meta name="description" content="面向对象把构成问题的transaction分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为，意在写出通用代码，加强代码重用，屏蔽差异性。" />
<meta property="og:locale" content="en-us" /><meta property="og:image" content="https://img.zburu.com/favicon.png" />

<link rel="stylesheet" href="/css/github-markdown.css">
<link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="/css/index.css">
<link href="/index.xml" rel="alternate" type="application/rss+xml" title="子舒的博客">
<script src="/js/jquery3.6.0.min.js"></script>
<link href="https://artalk.zburu.com/dist/Artalk.css" rel="stylesheet">
<link rel="stylesheet" href="/css/artalk.css">
<script src="https://artalk.zburu.com/dist/Artalk.js"></script>
<script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?5f4839173d00c8b0d3dd40533d14450d";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
  
</head>

<body>
  <div class="body">
    <header>
      <a href="/" class="logo">子舒的博客</a>
      <div class="header-title"></div>
      <div class="nav">
        <a href="/">首页</a>
        
        <a href="/blog/">归档</a>
        
        <a href="/message/">留言</a>
        
        <a href="/about/">关于</a>
        
        <a href="/lab/">实验室</a>
        
        <a href="/gpt/">GPT</a>
        
        <div class="icon">
          <a href="/index.xml" target="_blank"><svg xmlns="http://www.w3.org/2000/svg"
              class="icon icon-tabler icon-tabler-rss" width="24" height="24" viewBox="0 0 24 24" stroke-width="2"
              stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
              <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
              <path d="M5 19m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0"></path>
              <path d="M4 4a16 16 0 0 1 16 16"></path>
              <path d="M4 11a9 9 0 0 1 9 9"></path>
            </svg></a>
          <a href="/search"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search"
              width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none"
              stroke-linecap="round" stroke-linejoin="round">
              <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
              <path d="M10 10m-7 0a7 7 0 1 0 14 0a7 7 0 1 0 -14 0"></path>
              <path d="M21 21l-6 -6"></path>
            </svg></a>
        </div>
      </div>


      <div class="mob-menu">
        <em></em><em></em><em></em>
      </div>
    </header>
    <main class="main" id="pjax-container">

<section>
  <div class="single-title">面向对象编程</div>
  
  
  <div class="meta page-meta">
    <p>发布于<time datetime=" 2020-11-12 12:58:00 UTC">
        2020年11月12日</time></p>
    <i>-</i>
    <p>阅读量: <span id="ArtalkPV" data-page-key="/blog/15.html/"></span></p>
    <i>-</i>
    <p>评论数: <span id="ArtalkCount" data-page-key="/blog/15.html/"></span></p>
  </div>
  
  

  
  <nav id="TableOfContents">
  <ul>
    <li><a href="#一什么是面向对象编程">一、什么是面向对象编程</a>
      <ul>
        <li><a href="#1面向过程程序设计">1.面向过程程序设计</a></li>
        <li><a href="#2面向对象程序设计">2.面向对象程序设计</a></li>
      </ul>
    </li>
    <li><a href="#二创建对象的方法">二、创建对象的方法</a>
      <ul>
        <li><a href="#1创建字面量和实例">1.创建字面量和实例</a></li>
        <li><a href="#2工厂模式">2.工厂模式</a></li>
        <li><a href="#3构造函数">3.构造函数</a></li>
        <li><a href="#4-原型模式">4. 原型模式</a></li>
        <li><a href="#5混合模式推荐使用">5.混合模式(推荐使用)</a></li>
      </ul>
    </li>
    <li><a href="#三原型原型链">三、原型，原型链</a>
      <ul>
        <li><a href="#1原型对象">1.原型对象</a></li>
        <li><a href="#2__proto__和prototype的区别">2.__proto__和prototype的区别</a></li>
        <li><a href="#3继承">3.继承</a></li>
        <li><a href="#4es6新方法class">4.ES6新方法－－class</a></li>
      </ul>
    </li>
  </ul>
</nav>
  
  
  <div class="post-content markdown-body" id="post-content">
    
    <p>面向对象把构成问题的transaction分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为，意在写出通用代码，加强代码重用，屏蔽差异性。</p>
<!-- more -->
<h2 id="一什么是面向对象编程">一、什么是面向对象编程</h2>
<p>js是<code>基于原型</code>的，基于<code>面向对象编程</code></p>
<p>面向对象就是把数据和对数据的操作方法放在一起，作为一个整体——对象。对同类对象抽象出其共性，形成类</p>
<!-- more -->
<h3 id="1面向过程程序设计">1.面向过程程序设计</h3>
<p>将一个项目（或者一个事件）从头到尾按顺序，一步一步完成，先做什么，后做什么，一直到结束，也是我们人做事的方法。</p>
<p>自上而下，先确定一个整体的框架，然后添砖加瓦，逐步实现想要得到的效果，适用于简单的系统，容易理解。但是难以应对复杂的系统，不易维护扩展，难以复用</p>
<p>面向过程是分析解决问题的步骤，然后用函数把这些步骤一步一步的实现，然后在使用的时候一一调用则可。强调的是完成这件事儿的动作，更接近我们日常处理事情的思维。</p>
<h3 id="2面向对象程序设计">2.面向对象程序设计</h3>
<p>将一个项目（或者一个事件）分成更小的项目，每一个部分负责一方面的功能，最后由这些部分组成一个整体，先设计组件，在完成拼装，适用于大型复杂的系统</p>
<p>面向对象把构成问题的transaction分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为，意在写出通用代码，加强代码重用，屏蔽差异性。</p>
<p>想要弄明白面向对象，需要先理解类和对象的概念</p>
<p><a href="../20201118-objects-interfaces-classes">《什么是类和对象？》</a></p>
<h2 id="二创建对象的方法">二、创建对象的方法</h2>
<h3 id="1创建字面量和实例">1.创建字面量和实例</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>window.onload = <span style="color:#000080;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-style:italic">// 实例
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    <span style="color:#000080;font-weight:bold">var</span> person = <span style="color:#000080;font-weight:bold">new</span> Object();
</span></span><span style="display:flex;"><span>    person.name = <span style="color:#00f">&#39;小明&#39;</span>;
</span></span><span style="display:flex;"><span>    person.age = <span style="color:#00f">22</span>;
</span></span><span style="display:flex;"><span>    person.year = <span style="color:#000080;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>        console.log(<span style="color:#000080;font-weight:bold">this</span>.name + <span style="color:#00f">&#39;今年&#39;</span> + <span style="color:#000080;font-weight:bold">this</span>.age + <span style="color:#00f">&#39;岁了！&#39;</span>)
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    person.year();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-style:italic">// 字面量
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    <span style="color:#000080;font-weight:bold">var</span> student = {
</span></span><span style="display:flex;"><span>        name: <span style="color:#00f">&#39;小明&#39;</span>,
</span></span><span style="display:flex;"><span>        age: <span style="color:#00f">22</span>,
</span></span><span style="display:flex;"><span>        year: <span style="color:#000080;font-weight:bold">function</span> () {
</span></span><span style="display:flex;"><span>            console.log(<span style="color:#000080;font-weight:bold">this</span>.name + <span style="color:#00f">&#39;今年&#39;</span> + <span style="color:#000080;font-weight:bold">this</span>.age + <span style="color:#00f">&#39;岁了！&#39;</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    student.year();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">// 小明今年22岁了！
</span></span></span></code></pre></div><p>两者输出的结果是一样的，控制台输出：</p>
<blockquote>
<p>缺点：重复实例化对象，代码冗余高</p>
</blockquote>
<h3 id="2工厂模式">2.工厂模式</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>window.onload = <span style="color:#000080;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">function</span> createObj(name, age) {
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">var</span> obj = <span style="color:#000080;font-weight:bold">new</span> Object();
</span></span><span style="display:flex;"><span>        obj.name = name,
</span></span><span style="display:flex;"><span>        obj.age = age,
</span></span><span style="display:flex;"><span>        obj.year = <span style="color:#000080;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>            console.log(<span style="color:#000080;font-weight:bold">this</span>.name + <span style="color:#00f">&#39;今年&#39;</span> + <span style="color:#000080;font-weight:bold">this</span>.age + <span style="color:#00f">&#39;岁了！&#39;</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">return</span> obj;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">var</span> obj = createObj(<span style="color:#00f">&#39;小明&#39;</span>, <span style="color:#00f">22</span>);
</span></span><span style="display:flex;"><span>    obj.year();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">// 小明今年22岁了！
</span></span></span></code></pre></div><blockquote>
<p>优点：解决重复实例化对象的问题
缺点：无法识别对象的类型，因为所有的实例都指向一个原型</p>
</blockquote>
<h3 id="3构造函数">3.构造函数</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>window.onload = <span style="color:#000080;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">function</span> Person(name, age) {
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">this</span>.name = name;
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">this</span>.age = age;
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">this</span>.year = <span style="color:#000080;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>            console.log(<span style="color:#000080;font-weight:bold">this</span>.name + <span style="color:#00f">&#39;今年&#39;</span> + <span style="color:#000080;font-weight:bold">this</span>.age + <span style="color:#00f">&#39;岁了！&#39;</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">var</span> student = <span style="color:#000080;font-weight:bold">new</span> Person(<span style="color:#00f">&#39;小明&#39;</span>, <span style="color:#00f">22</span>);
</span></span><span style="display:flex;"><span>    student.year();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">// 小明今年22岁了！
</span></span></span></code></pre></div><blockquote>
<p>优点：可以识别对象的类型
缺点：多个实例重复创建方法，无法共享</p>
</blockquote>
<h3 id="4-原型模式">4. 原型模式</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>window.onload = <span style="color:#000080;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">function</span> Par() {}
</span></span><span style="display:flex;"><span>    Par.prototype = {
</span></span><span style="display:flex;"><span>        constructor: <span style="color:#00f">&#39;Par&#39;</span>,
</span></span><span style="display:flex;"><span>        name: <span style="color:#00f">&#39;小明&#39;</span>,
</span></span><span style="display:flex;"><span>        age: <span style="color:#00f">22</span>,
</span></span><span style="display:flex;"><span>        year: <span style="color:#000080;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>            console.log(<span style="color:#000080;font-weight:bold">this</span>.name + <span style="color:#00f">&#39;今年&#39;</span> + <span style="color:#000080;font-weight:bold">this</span>.age + <span style="color:#00f">&#39;岁了！&#39;</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">var</span> son = <span style="color:#000080;font-weight:bold">new</span> Par();
</span></span><span style="display:flex;"><span>    son.year();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">// 小明今年22岁了！
</span></span></span></code></pre></div><blockquote>
<p>缺点：所有实例共享他的属性和方法，不能传参和初始化属性值</p>
</blockquote>
<h3 id="5混合模式推荐使用">5.混合模式(推荐使用)</h3>
<p>是构造函数和原型模式混合的写法，拥有各自的优点，构造函数共享实例属性，原型模式共享方法和想要共享的属性，可以传参和初始化属性值</p>
<p>先用构造函数定义对象的属性方法，然后用原型模式创建方法，使用的属性通过prototype获取，有一个constructor属性，可以指向要操作的函数对象（构造函数）</p>
<p>比如<code>constructor: Par</code>，就代表下面这个原型方法指向<code>Par()</code>对象（构造函数）</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>window.onload = <span style="color:#000080;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">function</span> Par(name, age) {
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">this</span>.name = name;
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">this</span>.age = age;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    Par.prototype = {
</span></span><span style="display:flex;"><span>        constructor: Par,
</span></span><span style="display:flex;"><span>        year: <span style="color:#000080;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>            console.log(<span style="color:#000080;font-weight:bold">this</span>.name + <span style="color:#00f">&#39;今年&#39;</span> + <span style="color:#000080;font-weight:bold">this</span>.age + <span style="color:#00f">&#39;岁了！&#39;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">var</span> son = <span style="color:#000080;font-weight:bold">new</span> Par(<span style="color:#00f">&#39;小明&#39;</span>, <span style="color:#00f">22</span>)
</span></span><span style="display:flex;"><span>    son.year();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">// 小明今年22岁了！
</span></span></span></code></pre></div><h2 id="三原型原型链">三、原型，原型链</h2>
<h3 id="1原型对象">1.原型对象</h3>
<ol>
<li>函数对象都具有<code>prototype</code>属性，它指向函数的原型对象(浏览器内存创建的对象)，原型对象都具有<code>constructor</code>属性，它指向<code>prototype</code>属性所在的函数对象(构造函数)</li>
</ol>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>window.onload = <span style="color:#000080;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">function</span> Par(name, age) {
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">this</span>.name = name;
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">this</span>.age = age;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    Par.prototype = {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-style:italic">// constructor指向对象
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        constructor: Par,
</span></span><span style="display:flex;"><span>        year: <span style="color:#000080;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>            console.log(<span style="color:#000080;font-weight:bold">this</span>.name + <span style="color:#00f">&#39;今年&#39;</span> + <span style="color:#000080;font-weight:bold">this</span>.age + <span style="color:#00f">&#39;岁了！&#39;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">var</span> son = <span style="color:#000080;font-weight:bold">new</span> Par(<span style="color:#00f">&#39;小明&#39;</span>, <span style="color:#00f">22</span>)
</span></span><span style="display:flex;"><span>    son.year();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">/*********************************************/</span>
</span></span><span style="display:flex;"><span>    console.log(Par.prototype)
</span></span><span style="display:flex;"><span>    console.log(Par.prototype.constructor)
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">/*********************************************/</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>通过控制台可以看到</p>
<p>构造函数的<code>prototypr</code>属性指向原型对象</p>
<p>原型对象的<code>construcyor</code>属性指向构造函数</p>
<ol>
<li>当调用构造函数创建一个实例后，该实例会有一个隐藏属性<code>__proto__ </code>，它指向构造函数的原型对象</li>
</ol>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>console.log(son.__proto__ === Par.prototype)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">// true
</span></span></span></code></pre></div><ol start="3">
<li>所有的构造函数的prototype都是object类型</li>
</ol>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>console.log(<span style="color:#000080;font-weight:bold">typeof</span> Par.prototype)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">// object
</span></span></span></code></pre></div><ol start="4">
<li>Function的prototype是一个空函数，所有内置函数的__proto__属性都指向这个空函数</li>
</ol>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>console.log(Math.__proto__)
</span></span></code></pre></div><ol>
<li>如果构造函数实例和原型对象中同时定义了一个属性，在调用时，会屏蔽原型对象中的属性，如果想要访问原型对象中的属性值，需要通过<code>delete</code>方法将同名属性在实例（构造函数）中彻底删除</li>
</ol>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>window.onload = <span style="color:#000080;font-weight:bold">function</span> () {
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">function</span> Par(name) {
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">this</span>.name = name;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    Par.prototype.name = <span style="color:#00f">&#34;张三&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">var</span> son = <span style="color:#000080;font-weight:bold">new</span> Par(<span style="color:#00f">&#34;李四&#34;</span>);
</span></span><span style="display:flex;"><span>    console.log(son.name); <span style="color:#080;font-style:italic">// 李四
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    console.log(son.__proto__.name); <span style="color:#080;font-style:italic">// 张三
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-style:italic">// 使用delete删除实例的同名属性值
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    console.log(<span style="color:#000080;font-weight:bold">delete</span> son.name);   <span style="color:#080;font-style:italic">// true
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    console.log(son.name); <span style="color:#080;font-style:italic">// 张三
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>}
</span></span></code></pre></div><ol start="6">
<li>通过<code>hasOwnProperty(属性名)</code>可以判断一个属性存在于构造函数中，还是原型对象中</li>
</ol>
<blockquote>
<p><code>true</code>表示存在构造函数中；<code>false</code>表示存在原型对象中</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>console.log(Par.hasOwnProperty(name));  <span style="color:#080;font-style:italic">// false
</span></span></span></code></pre></div><ol start="7">
<li>操作符<code>in</code>，可以判断一个属性是否存在（存在于构造函数和原型对象中皆可）</li>
</ol>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>window.onload = <span style="color:#000080;font-weight:bold">function</span> () {
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">function</span> Par(name, age) {
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">this</span>.name = name;
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">this</span>.age = age;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    Par.prototype = {
</span></span><span style="display:flex;"><span>        constructor: Par,
</span></span><span style="display:flex;"><span>        year: <span style="color:#000080;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>            console.log(<span style="color:#000080;font-weight:bold">this</span>.name + <span style="color:#000080;font-weight:bold">this</span>.age)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">var</span> son = <span style="color:#000080;font-weight:bold">new</span> Par(<span style="color:#00f">&#39;xm&#39;</span>, <span style="color:#00f">&#39;22&#39;</span>)
</span></span><span style="display:flex;"><span>    son.year();
</span></span><span style="display:flex;"><span>    console.log(<span style="color:#00f">&#39;name&#39;</span> <span style="color:#000080;font-weight:bold">in</span> Par); <span style="color:#080;font-style:italic">// true
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    console.log(<span style="color:#00f">&#39;age&#39;</span> <span style="color:#000080;font-weight:bold">in</span> Par);  <span style="color:#080;font-style:italic">// false
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>}
</span></span></code></pre></div><p>同样的两个属性，判断其是否存在于实例或者原型对象中，输出的结果不一样</p>
<blockquote>
<p>参考:《对象中是否有某一个属性 in》<a href="https://www.cnblogs.com/IwishIcould/p/12333739.html">https://www.cnblogs.com/IwishIcould/p/12333739.html</a></p>
</blockquote>
<h3 id="2__proto__和prototype的区别">2.__proto__和prototype的区别</h3>
<ol>
<li>
<p><code>prototype</code>属性只有函数对象上才有，而<code>__proto__</code>属性所有对象都有</p>
</li>
<li>
<p><code>prototype</code>是由函数对象指向原型对象，而<code>__proto__</code>是由实例指向函数对象的原型对象</p>
</li>
<li>
<p>原型链，将父类型的实例作为子类型的原型对象，这种链式关系叫做<code>原型链</code></p>
</li>
</ol>
<h3 id="3继承">3.继承</h3>
<ol>
<li>原型链继承</li>
</ol>
<blockquote>
<p>优点：父类原型定义的属性和方法可以复用
缺点：子类实例没有自己的属性，不能向父类传递参数</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">function</span> test1() {
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">function</span> SuperType() {
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">this</span>.city = [ <span style="color:#00f">&#34;北京&#34;</span>, <span style="color:#00f">&#34;上海&#34;</span>, <span style="color:#00f">&#34;天津&#34;</span> ];
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">this</span>.property = <span style="color:#000080;font-weight:bold">true</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    SuperType.prototype = {
</span></span><span style="display:flex;"><span>        constructor : SuperType,     <span style="color:#080;font-style:italic">// 保持构造函数和原型对象的完整性
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        age : <span style="color:#00f">15</span>,
</span></span><span style="display:flex;"><span>        getSuperValue : <span style="color:#000080;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#000080;font-weight:bold">return</span> <span style="color:#000080;font-weight:bold">this</span>.property;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">function</span> SonType() {
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">this</span>.property = <span style="color:#000080;font-weight:bold">false</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-style:italic">// 重写子类的原型指向父类的实例：继承父类的原型
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    SubType.prototype = <span style="color:#000080;font-weight:bold">new</span> SuperType();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    SubType.prototype = {
</span></span><span style="display:flex;"><span>        constructor : SubType,
</span></span><span style="display:flex;"><span>        getSonType : <span style="color:#000080;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#000080;font-weight:bold">return</span> <span style="color:#000080;font-weight:bold">this</span>.property;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-style:italic">// 优点验证
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    <span style="color:#000080;font-weight:bold">let</span> son = <span style="color:#000080;font-weight:bold">new</span> SubType();
</span></span><span style="display:flex;"><span>    console.log(son.age); <span style="color:#080;font-style:italic">// 15
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    console.log(son.getSuperValue()); <span style="color:#080;font-style:italic">// false
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-style:italic">// 缺点验证
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    <span style="color:#000080;font-weight:bold">let</span> instance1 = <span style="color:#000080;font-weight:bold">new</span> SubType();
</span></span><span style="display:flex;"><span>    instance1.city.push(<span style="color:#00f">&#34;重庆&#34;</span>);
</span></span><span style="display:flex;"><span>    console.log(instance1.city); <span style="color:#080;font-style:italic">// [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;, &#34;重庆&#34;]
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">let</span> instance2 = <span style="color:#000080;font-weight:bold">new</span> SubType();
</span></span><span style="display:flex;"><span>    console.log(instance2.city); <span style="color:#080;font-style:italic">// [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;, &#34;重庆&#34;]
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">// test1();
</span></span></span></code></pre></div><ol start="2">
<li>构造函数继承</li>
</ol>
<blockquote>
<p>优点：子类实例有自己的属性，可以向父类传递参数，解决原型链继承的缺点
缺点：父类原型的属性和方法不可复用</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">function</span> test2() {
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">function</span> SuperType(name) {
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">this</span>.name = name;
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">this</span>.city = [ <span style="color:#00f">&#34;北京&#34;</span>, <span style="color:#00f">&#34;上海&#34;</span>, <span style="color:#00f">&#34;天津&#34;</span> ]
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    SuperType.prototype = {
</span></span><span style="display:flex;"><span>        constructor : SuperType,
</span></span><span style="display:flex;"><span>        age : <span style="color:#00f">18</span>,
</span></span><span style="display:flex;"><span>        showInfo : <span style="color:#000080;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#000080;font-weight:bold">return</span> <span style="color:#000080;font-weight:bold">this</span>.name;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">function</span> SubType() {
</span></span><span style="display:flex;"><span>        <span style="color:#080;font-style:italic">// 父类调用call()或者apply()方法和子类共用同一个this，实现子类实例属性的继承
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        SuperType.call(<span style="color:#000080;font-weight:bold">this</span>, <span style="color:#00f">&#34;张三&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-style:italic">// 优点验证
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    <span style="color:#000080;font-weight:bold">let</span> instance = <span style="color:#000080;font-weight:bold">new</span> SubType();
</span></span><span style="display:flex;"><span>    instance.city.push(<span style="color:#00f">&#34;重庆&#34;</span>);
</span></span><span style="display:flex;"><span>    console.log(instance.city); <span style="color:#080;font-style:italic">// [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;, &#34;重庆&#34;]
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">let</span> instance1 = <span style="color:#000080;font-weight:bold">new</span> SubType();
</span></span><span style="display:flex;"><span>    console.log(instance1.city); <span style="color:#080;font-style:italic">// [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;]
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-style:italic">// 缺点验证
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    console.log(instance.age); <span style="color:#080;font-style:italic">// undefined
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    instance.showInfo(); <span style="color:#080;font-style:italic">// son.showInfo is not a function
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">// test2();
</span></span></span></code></pre></div><ol start="3">
<li>组合继承（推荐）</li>
</ol>
<blockquote>
<p>优点：原型的属性和方法可以复用，每个子类实例都有自己的属性
缺点：父类构造函数调用了两次，子类原型中的父类实例属性被子类实例覆盖</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">function</span> test3() {
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">function</span> SuperType(name) {
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">this</span>.name = name;
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">this</span>.city = [ <span style="color:#00f">&#34;北京&#34;</span>, <span style="color:#00f">&#34;上海&#34;</span>, <span style="color:#00f">&#34;天津&#34;</span> ]
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    SuperType.prototype = {
</span></span><span style="display:flex;"><span>        constructor : SuperType,
</span></span><span style="display:flex;"><span>        showInfo : <span style="color:#000080;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>            console.log(<span style="color:#000080;font-weight:bold">this</span>.name + <span style="color:#00f">&#34;今年&#34;</span> + <span style="color:#000080;font-weight:bold">this</span>.age + <span style="color:#00f">&#34;岁了&#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">function</span> SubType(name, age) {
</span></span><span style="display:flex;"><span>        <span style="color:#080;font-style:italic">// 1. 通过构造方法继承实现实例属性的继承
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        SuperType.call(<span style="color:#000080;font-weight:bold">this</span>, name);
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">this</span>.age = age;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-style:italic">// 2. 通过原型链继承实现原型方法的继承
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    SubType.prototype = <span style="color:#000080;font-weight:bold">new</span> SuperType();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-style:italic">// 优点验证
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    <span style="color:#000080;font-weight:bold">let</span> instance = <span style="color:#000080;font-weight:bold">new</span> SubType(<span style="color:#00f">&#34;张三&#34;</span>, <span style="color:#00f">15</span>);
</span></span><span style="display:flex;"><span>    instance.showInfo(); <span style="color:#080;font-style:italic">// 张三今年15岁了
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">let</span> instance1 = <span style="color:#000080;font-weight:bold">new</span> SubType();
</span></span><span style="display:flex;"><span>    instance1.city.push(<span style="color:#00f">&#34;重庆&#34;</span>);
</span></span><span style="display:flex;"><span>    console.log(instance1.city); <span style="color:#080;font-style:italic">// [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;, &#34;重庆&#34;]
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">let</span> instance2 = <span style="color:#000080;font-weight:bold">new</span> SubType();
</span></span><span style="display:flex;"><span>    console.log(instance2.city); <span style="color:#080;font-style:italic">// [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;]
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">// test3();
</span></span></span></code></pre></div><ol start="4">
<li>寄生组合继承（推荐）</li>
</ol>
<blockquote>
<p>优点：解决了组合继承的缺点，效率高
缺点：基本没有</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">function</span> test4() {
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">function</span> inheritPrototype(subType, superType) {
</span></span><span style="display:flex;"><span>        <span style="color:#080;font-style:italic">// 1. 继承父类的原型
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        <span style="color:#000080;font-weight:bold">var</span> prototype = Object.create(superType.prototype);
</span></span><span style="display:flex;"><span>        <span style="color:#080;font-style:italic">// 2. 重写被污染的construct
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        prototype.constructor = subType;
</span></span><span style="display:flex;"><span>        <span style="color:#080;font-style:italic">// 3. 重写子类的原型
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        subType.prototype = prototype;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">function</span> SuperType(name) {
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">this</span>.name = name;
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">this</span>.city = [ <span style="color:#00f">&#34;北京&#34;</span>, <span style="color:#00f">&#34;上海&#34;</span>, <span style="color:#00f">&#34;天津&#34;</span> ];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    SuperType.prototype.sayName = <span style="color:#000080;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>        console.log(<span style="color:#000080;font-weight:bold">this</span>.name);
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">function</span> SubType(name, age) {
</span></span><span style="display:flex;"><span>        SuperType.call(<span style="color:#000080;font-weight:bold">this</span>, name);
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">this</span>.age = age;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-style:italic">// 将父类原型指向子类
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    inheritPrototype(SubType, SuperType);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    SubType.prototype.sayAge = <span style="color:#000080;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>        console.log(<span style="color:#000080;font-weight:bold">this</span>.age);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-style:italic">// 优点验证
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    <span style="color:#000080;font-weight:bold">let</span> instance = <span style="color:#000080;font-weight:bold">new</span> SubType(<span style="color:#00f">&#34;张三&#34;</span>, <span style="color:#00f">15</span>);
</span></span><span style="display:flex;"><span>    instance.sayName(); <span style="color:#080;font-style:italic">// 张三
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">let</span> instance1 = <span style="color:#000080;font-weight:bold">new</span> SubType();
</span></span><span style="display:flex;"><span>    instance1.city.push(<span style="color:#00f">&#34;重庆&#34;</span>);
</span></span><span style="display:flex;"><span>    console.log(instance1.city); <span style="color:#080;font-style:italic">// [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;, &#34;重庆&#34;]
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">let</span> instance2 = <span style="color:#000080;font-weight:bold">new</span> SubType();
</span></span><span style="display:flex;"><span>    console.log(instance2.city); <span style="color:#080;font-style:italic">// [&#34;北京&#34;, &#34;上海&#34;, &#34;天津&#34;]
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">// test4();
</span></span></span></code></pre></div><h3 id="4es6新方法class">4.ES6新方法－－class</h3>
<p>新的关键字<code>class</code>在es6开始被引入到javascript中来，<code>class</code>的目的就是让定义类更简单</p>
<p>用函数方法实现：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">function</span> Person(name) {
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">this</span>.name = name;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Person.prototype.hello = <span style="color:#000080;font-weight:bold">function</span> () {
</span></span><span style="display:flex;"><span>    console.log(<span style="color:#00f">&#39;Hello, &#39;</span> + <span style="color:#000080;font-weight:bold">this</span>.name + <span style="color:#00f">&#39;!&#39;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">var</span> son = <span style="color:#000080;font-weight:bold">new</span> Person(<span style="color:#00f">&#39;xm&#39;</span>)
</span></span><span style="display:flex;"><span>son.hello();    <span style="color:#080;font-style:italic">// Hello, xm!
</span></span></span></code></pre></div><p>用<code>class</code>来实现：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">class</span> Person {
</span></span><span style="display:flex;"><span>    constructor(name) {
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">this</span>.name = name;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    hello() {
</span></span><span style="display:flex;"><span>        console.log(<span style="color:#00f">&#39;Hello, &#39;</span> + <span style="color:#000080;font-weight:bold">this</span>.name + <span style="color:#00f">&#39;!&#39;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">var</span> son = <span style="color:#000080;font-weight:bold">new</span> person(<span style="color:#00f">&#39;xm&#39;</span>)
</span></span><span style="display:flex;"><span>son.hello();    <span style="color:#080;font-style:italic">// Hello, xm!
</span></span></span></code></pre></div><p>可以在看到，在定义<code>class</code>中，直接包含了构造函数<code>constructor</code>属性，和原型对象上的函数<code>hello()</code>方法，省略掉了<code>function</code>关键字</p>
<p>需要注意：原来的写法是，构造函数和原型对象分散开来写，现在用<code>class</code>可以直接把两者串在一个对象中，只有最后传参和调用方法时写法是一样的</p>
<p><strong>class继承</strong></p>
<p>用<code>class</code>定义对象的另一个巨大的好处是继承更方便了。想一想我们从<code>Person</code>派生一个<code>PrimaryPerson</code>需要编写的代码量。现在，原型继承的中间对象，原型对象的构造函数等等都不需要考虑了，直接通过<code>extends</code>来实现：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">class</span> PrimaryPerson <span style="color:#000080;font-weight:bold">extends</span> Person {
</span></span><span style="display:flex;"><span>    constructor(name, grade) {
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">super</span>(name); <span style="color:#080;font-style:italic">// 记得用super调用父类的构造方法!
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        <span style="color:#000080;font-weight:bold">this</span>.grade = grade;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    myGrade() {
</span></span><span style="display:flex;"><span>        alert(<span style="color:#00f">&#39;I am at grade &#39;</span> + <span style="color:#000080;font-weight:bold">this</span>.grade);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>注意<code>PrimaryPerson</code>的定义也是通过class关键字实现的，而<code>extends</code>则表示原型链对象来自<code>Person</code>，子类的构造函数可能会和父类的不太相同</p>
<p>例如，<code>PrimaryPerson</code>需要<code>name</code>和<code>grade</code>两个参数，并且需要通过<code>super(name)</code>来调用父类的构造函数，否则父类的<code>name</code>属性无法正常初始化。</p>
<p><code>PrimaryPerson</code>已经自动获得了父类<code>Person</code>的<code>hello方法</code>，我们又在子类中定义了新的<code>myGrade</code>方法。</p>
<p>ES6引入的<code>class</code>和原有的<code>JavaScript原型继承</code>有什么区别呢？</p>
<p>实际上它们没有任何区别，<code>class</code>的作用就是让JavaScript引擎去实现原来需要我们自己编写的原型链代码。简而言之，用<code>class</code>的好处就是极大地简化了原型链代码。</p>
<p>但是！</p>
<p>目前并不是所有的浏览器都支持<code>class</code>，所以在选择的时候一定要慎重！</p>

  </div>

  
  
  <div class="tags">
    <span>Tags: </span>
     
    <a href="https://zburu.com/tags/%E7%BC%96%E7%A8%8B">编程</a>
     
    <a href="https://zburu.com/tags/js">js</a>
    
  </div>
  

</section>




<section>
  <h4>评论~</h4>
  <div id="Comments"></div>
<script>
  Artalk.init({
    el: '#Comments',
    pageKey: '',
    pageTitle: '',
    server: 'https://artalk.zburu.com',
    site: '子舒的博客',
  })
</script>
</section>


</main>
<footer>
  <div>© 2020 - <span id="year"></span></div>
  <div>
    <a href="https://beian.miit.gov.cn/" target="_blank"><span>浙ICP备2022002453号-2</span></a>
  </div>
  <div>Powered by <a href="https://github.com/lovezsh">子舒</a></div>
  <div>网站已经运行 <span id="days">0</span></div>
  <div class="gotop">▲</div>
</footer>
<script>
  var s0 = '2020-06-14';
  s1 = new Date(s0.replace(/-/g, "/"));
  s2 = new Date();
  var days = s2.getTime() - s1.getTime();

  var date = new Date;
  var year = date.getFullYear();
  document.getElementById('year').innerHTML = year;

  var BootDate = new Date("2020-06-14");
  function ShowRunTime(id) {
    var NowDate = new Date();
    var RunDateM = parseInt(NowDate - BootDate);
    var RunDays = Math.floor(RunDateM / (24 * 3600 * 1000));
    var RunHours = Math.floor(RunDateM % (24 * 3600 * 1000) / (3600 * 1000));
    var RunMinutes = Math.floor(RunDateM % (24 * 3600 * 1000) % (3600 * 1000) / (60 * 1000));
    var RunSeconds = Math.round(RunDateM % (24 * 3600 * 1000) % (3600 * 1000) % (60 * 1000) / 1000);
    var days = RunDays + "天" + RunHours + "时" + RunMinutes + "分" + RunSeconds + "秒";
    document.getElementById(id).innerHTML = days;
  }
  ShowRunTime('days');
  setInterval("ShowRunTime('days')", 1000);
</script>

<script>
 Artalk.loadCountWidget({
    server: 'https://artalk.zburu.com',
    site: '子舒的博客',
  })
</script>
<script src="/js/simplebox.min.js"></script>
<script src="/js/search.js"></script>
<script src="/js/main.js"></script>
<script src="/js/jquery.pjax.js"></script>
<script>
  $(document).pjax('a', '#pjax-container')
</script>
</div>
</body>

</html>