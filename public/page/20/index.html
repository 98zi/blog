<!DOCTYPE html>
<html lang="en-us">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Hugo 0.117.0">
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="toTop" content="true">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="author" content="" />
<meta property="og:url" content="/" />
<link rel="canonical" href="/" /><link rel="apple-touch-icon" href="https://imgurl.zishu.me/favicon2.png" />
<link rel="icon" href="https://imgurl.zishu.me/favicon2.png" />
<link rel="shortcut" href="https://imgurl.zishu.me/favicon2.png" /><link rel="alternate" type="application/atom+xml" href="index.xml" title="子舒的博客">
<script type="application/ld+json">
{
"@context" : "http://schema.org",
"@type" : "BlogPosting",
"mainEntityOfPage": {
"@type": "WebPage",
"@id": ""
},
"articleSection" : "",
"name" : "子舒的博客",
"headline" : "子舒的博客",
"description" : "",
"inLanguage" : "en-US",
"author" : "子舒",
"creator" : "子舒",
"publisher": "子舒",
"accountablePerson" : "子舒",
"copyrightHolder" : "子舒",
"copyrightYear" : "2023",
"datePublished": "2023-09-02 00:00:00 \u002b0000 UTC",
"dateModified" : "2023-09-02 00:00:00 \u002b0000 UTC",
"url" : "\/",
"keywords" : [  ]
}
</script><title>子舒的博客</title>
<meta property="og:title" content="子舒的博客" />
<meta property="og:type" content="website" />
<meta property="og:description" content="" />
<meta name="description" content="" />
<meta property="og:locale" content="en-us" /><meta property="og:image" content="https://imgurl.zishu.me/favicon2.png" />


<link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="/css/index.css">

<link href="/index.xml" rel="alternate" type="application/rss+xml" title="子舒的博客">
<script src="/js/jquery3.6.0.min.js"></script>
<script async src="https://umami.zburu.com/script.js" data-website-id="9e5fc8da-b70b-4767-81cd-35ba13110fd5"></script>
</head>

<body>
  <header class="header">
    <nav class="nav">
      <div class="logo">
        <a href="/">zishu.me</a>
        <div class="logo-switches">
          <button id="theme-toggle" accesskey="t" title="(Alt + T)">
            <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none"
              stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
            </svg>
            <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none"
              stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <circle cx="12" cy="12" r="5"></circle>
              <line x1="12" y1="1" x2="12" y2="3"></line>
              <line x1="12" y1="21" x2="12" y2="23"></line>
              <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
              <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
              <line x1="1" y1="12" x2="3" y2="12"></line>
              <line x1="21" y1="12" x2="23" y2="12"></line>
              <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
              <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
            </svg>
          </button>
        </div>
      </div>
      <ul id="menu">
        
        <li>
          <a href="/blog/" title="归档"><span>归档</span></a>
        </li>
        
        <li>
          <a href="/message/" title="留言板"><span>留言板</span></a>
        </li>
        
        <li>
          <a href="/lab/" title="实验室"><span>实验室</span></a>
        </li>
        
        <li>
          <a href="/about/" title="关于"><span>关于</span></a>
        </li>
        
        <li>
          <a href="/search/" title="Search"><span>Search</span></a>
        </li>
        
        <li>
          <a href="/index.xml" title="RSS"><span>RSS</span></a>
        </li>
        
      </ul>
    </nav>
  </header>

  <main class="container">
    <div class="content">
<script>$('body').addClass('list')</script>

<div class="main">
  <article class="first-entry home-info">
    <header class="entry-header">
      <h1>Hi Friend 😁</h1>
    </header>
    <div class="entry-content">
      <p>
        我是子舒。<br>
        前端程序员，独立博客作者，骑行爱好者，摄影爱好者，INFJ人格。<br>
        现在生活工作在杭州。<br>
        这是我在闲暇时间写的博客，记录生活。
      </p>
    </div>
    <footer class="entry-footer">
      <div class="social-icons">
        <a href="https://github.com/zishume" target="_blank" rel="noopener noreferrer me" title="Github">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
            stroke-linecap="round" stroke-linejoin="round">
            <path
              d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22">
            </path>
          </svg>
        </a>
        <a href="/index.xml" target="_blank" rel="noopener noreferrer me" title="Rss">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
            stroke-linecap="round" stroke-linejoin="round">
            <path d="M4 11a9 9 0 0 1 9 9"></path>
            <path d="M4 4a16 16 0 0 1 16 16"></path>
            <circle cx="5" cy="19" r="1"></circle>
          </svg>
        </a>
      </div>
    </footer>
  </article>

  
  
  
  
  

  <article class="post-entry">
    <header class="entry-header">
      <h2>许嵩的歌又一次被抄袭！</h2>
    </header>
    <div class="entry-content">
      <p>最新网上爆出风风火火的一件事，许嵩的《有何不可》被抄袭，抄袭者为罗聪，《简单的幸福》。 我从14年开始听许嵩的歌，一直到现在，许多年过去了，他的歌依旧脍炙人口，从之前的抒情浪漫情歌，批判社会的思想，一直到现在具体哲学内涵，中华传统思想。大部分都是包揽作词作曲为一身，真的很有才华。 因为太有才华了，所以被“碰瓷”抄袭。这也算是一场闹剧了。据说嵩哥本人对此没有发表什么看法和言论，一直都是粉丝和公司在发声。 据网友戏称：“许嵩：这要放十年前，我早写歌骂你了。”，“低情商：这不就是抄袭《有何不可》？高情商：你这《有何不可》唱得有点跑调”。 令人没有想象到的事，罗聪所在公司发表声明： 突然感觉有些搞笑，我也不对他再发表什么看法，只希望官方能解决这件事，给我们松鼠一个交代。 要是靠抄袭就能火的话，还要才华做什么。 这也一直是我的理念，在写博客的时候，我也很注重版权，引用别人写的文章的时候，我都会申请作者授权，标明出处。同时，对于我自己的文章，如果你想要引用转载，只需要标明出处即可。 大部分做技术的人应该都是和我抱有一样的想法，喜欢分享，但是可不能张冠李戴，毕竟写文章也是耗费脑细胞的。并不指望能获得什么成绩，只是希望当有人看到你的文章时，解决了自己的问题，有一丝认可足以。 版权一直是一件很重要的事情，很多年前我们还比较淡漠，但是这几年对版权的重视开始慢慢提升了，审查力度增加，这是一件好事。</p>
    </div>
    <footer class="entry-footer">
      <time datetime=" 2021-01-16 00:00:00 UTC"> January 16, 2021</time>
    </footer>
    <a class="entry-link" aria-label="post link to Installation | Update" href="/blog/45.html/"></a>
  </article>

  
  
  

  <article class="post-entry">
    <header class="entry-header">
      <h2>基于 React 的富文本编辑器－－Braft Editor</h2>
    </header>
    <div class="entry-content">
      <p>最近发了很多关于 React 的文章，记录遇到的新技术点，以及在写代码过程中遇到的问题，希望可以帮助到和我遇到同样问题的同学。 今天分享的是一款基于 React 的富文本编辑器－－Braft Editor。 Braft Editor 官网：https://braft.margox.cn Github 仓库地址：https://github.com/margox/braft-editor 这款插件非常方便，只需要下载然后引入即可直接使用，页面整体风格清新，符合绝大多数人的审美观，支持图片，音视频的插入。 按照官方的说法，假如你对它的功能还不够满意，不够使用，完全可以扩展它，自己写一个插件来强化他。 经过我的测试，功能绝对强大，可以满足市面上绝大多数的需求。接下来就说一下如何使用这款插件。 1.安装 在项目中直接通过 npm 或者 yarn 下载插件： # 使用 npm 安装 npm install braft-editor --save # 使用 yarn 安装 yarn add braft-editor 2.使用 新建一个组件 EditorDemo.js，在里面写入下列代码： // EditorDemo.js import React from &#39;react&#39;; import BraftEditor from &#39;braft-editor&#39;; import &#39;braft-editor/dist/index.css&#39;; export default class PageDemo extends React.Component { state = { editorState: BraftEditor.createEditorState(null) } render () { return ( &lt;BraftEditor value={this.state.editorState} onChange={this.handleChange}/&gt; ) } handleChange = (editorState) =&gt; { this.setState({ editorState }) } } 然后引入到 index.js 中去。 3.运行 写完组件之后，npm start 运行看看效果 相当不错，页面很简洁，如果觉得样式不喜欢，完全可以自己重新定制风格，非常方便。 4.文档 如果想使用更多功能、方法，进入 Braft Editor 官方文档吧，还有更多关于它的讲解！ 属性、方法、示例，一应俱全。</p>
    </div>
    <footer class="entry-footer">
      <time datetime=" 2021-01-07 00:00:00 UTC"> January 07, 2021</time>
    </footer>
    <a class="entry-link" aria-label="post link to Installation | Update" href="/blog/44.html/"></a>
  </article>

  
  
  

  <article class="post-entry">
    <header class="entry-header">
      <h2>使用 React 与 Vue 创建同一款 App，差别究竟有多大？</h2>
    </header>
    <div class="entry-content">
      <p>关于 React 框架 和 Vue 框架 的对比，用两者写出同一个程序，对比其代码实现的过程，看看它们的差异究竟有多大？ 转载于：https://blog.csdn.net/csdnnews/article/details/81880378 原文：https://medium.com/javascript-in-plain-english/i-created-the-exact-same-app-in-react-and-vue-here-are-the-differences-e9a1ae8077fd 作者简介：Sunil Sandhu，一位 Web 全栈工程师 + 空想家。 译者：安翔，责编：屠敏 众所周知，Vue 和 React 都是目前非常著名的前端框架。我在工作中经常使用 Vue，因此我对它有很深入的了解。同时，我也对 React 充满了好奇，想要学习一下，一探究竟。 于是我阅读了 React 文档并观看了一些视频教程，虽然这些资料很不错，但是我真正想了解的是 React 与 Vue 之间的不同之处。所谓“不同之处”，我并非想知道它们是否都具有虚拟 DOMS 或者它们如何渲染页面，而是希望有人能够从代码的角度解释这两者之间的差异。我想找到一篇解释这些差异的文章，以便 Vue 或者 React 的初学者可以更好地理解它们两者之间的差异。 很遗憾，我并未找到一篇这样的文章。于是我意识到必须自己动手来比较 Vue 与 React 之间的异同。在我自力更生的过程中，我用这篇文章记录下了具体过程。 1.目标 我将会构建一个标准的待办事项应用程序，允许用户添加和删除列表中的项目。这两个应用程序都使用默认的 CLI（command-line interface，命令行界面） 构建，React 使用 create-react-app，Vue 使用 vue-cli。 两个应用程序的外观如下： 两个应用程序的 CSS 代码几乎一样，但这些代码的位置存在差异。考虑到这一点，我们来看看这两个应用程序的文件结构： 你会发现它们的结构几乎完全相同。唯一的区别在于 React App 拥有三个 CSS 文件，而 Vue App 中没有 CSS 文件。这是因为 React 的 create-react-app 组件需要一个附带文件来保存其样式，而 Vue CLI 采用全包方法，其样式在实际组件文件中声明。 两种不同的策略得到的结果是一样的，相信开发者很快能够掌握这两种不同的策略。开发者可以根据自己的偏好做出选择，你会听到开发社区关于如何构建 CSS 的大量讨论。以上，我们遵循两个 CLI 列出了代码结构。 在我们进一步讨论之前，先快速看一下典型的 Vue 和 React 组件的外观： 现在让我们正式开始，深入其中的细节！ 2.如何修改数据 首先，我们需要明白“修改数据”的意思是什么。它听起来有些学术，但实际上很简单，就是把我们已经存储好的数据进行更改。比如，如果我们想把一个人的名字变量从“Jhon”改为“Mark”，我们就需要执行“修改数据”的操作。在这一点上，React 和 Vue 的处理方式有所区别。Vue 本质上会创建一个数据对象，其中的数据可以自由更改；React 则创建一个状态对象，更改数据需要一些额外的操作。React 之所以需要额外的操作有着自己的理由，稍后我会深入介绍。在此之前，我们先看看 Vue 中的数据对象和 React 中的状态对象： vue 数据对象 React 状态对象 从图中可以看出，我们传入了相同的数据，但它们的标记方法不同。因此，将初始数据传递到组件的方式非常相似。但正如我们提到的那样，在两个框架中更改数据的方式有所不同。 假设我们有一个名为 name: ‘Sunil’ 的数据元素。 在 Vue 中，我们通过调用 this.name 来引用它。我们也可以通过调用 this.name =&lsquo;John&rsquo; 来更新它。这样一来，名字就被成功改为了 “Jhon”。 在 React 中，我们通过调用 this.state.name 来引用同一段数据。现在关键的区别在于，我们不能简单地写成 this.state.name =&lsquo;John&rsquo;，因为 React 有限制机制，它会阻止这种简单的修改方式。在 React 中，我们需要这样写：this.setState({name：&lsquo;John&rsquo;})。 虽然这基本上与我们在 Vue 中实现的结果一样，但是 React 的操作更为繁琐，那是因为 Vue 在每次更新数据时默认组合了自己的 setState 版本。 简单来说就是，React 需要 setState，然后更新其内部数据，而对于 Vue 来说，当你更新数据对象的值时它就默认了你的更改意图。 那么为什么 React 没有进行简化，为什么需要 setState 呢？ Revanth Kumar 对此做出了解释： “这是因为 React 希望在状态发生变化时重新运行某些生命周期 hook，比如 componentWillReceiveProps、shouldComponentUpdate、componentWillUpdate、render、componentDidUpdate。当你调用 setState 函数时，它知道状态已经改变。如果你直接改变状态，React 将需要做更多工作来跟踪更改以及运行生命周期 hook 等等。所以为了简单起见，React 使用 setState。&quot; 3.添加新的待办事项 React 的实现方法 createNewToDoItem = () =&gt; { this.setState( ({ list, todo }) =&gt; ({ list: [ ...list, { todo } ], todo: &#39;&#39; }) ); }; 在 React 中，我们的输入字段有一个名为 value 的属性。这个 value 通过使用几个函数自动更新，这些函数绑定在一起以创建双向绑定。我们通过在输入字段上附加一个 onChange 事件监听器来创建这种形式的双向绑定。看看代码，一探究竟： &lt;input type=&#34;text&#34; value={this.state.todo} onChange={this.handleInput}/&gt; 只要输入字段的值发生更改，handleInput 函数就会运行。它通过将状态对象设置为输入字段中的任何内容来更新状态对象内的 todo。handleInput 函数如下： handleInput = e =&gt; { this.setState({ todo: e.target.value }); }; 现在，只要用户按下页面上的 + 按钮添加新项目，createNewToDoItem 函数就会运行 this.setState 并向其传递一个函数。该函数有两个参数，第一个是来自状态对象的整个列表数组，第二个是由 handleInput 函数更新的todo。然后该函数返回一个新对象，该对象包含之前的整个列表，并在其末尾添加todo。整个列表是通过使用扩展运算符添加的。 最后，我们将 todo 设置为空字符串，它会自动更新输入字段中的 value。 Vue 的实现方法 createNewToDoItem() { this.list.push( { &#39;todo&#39;: this.todo } ); this.todo = &#39;&#39;; } 在 Vue 中，我们的输入字段中有一个名为 v-model 的句柄。这实现了**双向绑定。输入字段代码如下： &lt;input type=&#34;text&#34; v-model=&#34;todo&#34;/&gt; V-Model 将输入字段的内容绑定到名为 toDoItem 的数据对象的键（key）上。当页面加载时，我们将 toDoItem 设置为空字符串，比如：todo：&rsquo; &lsquo;。如果已经存在数据，例如 todo：&lsquo;添加文本处&rsquo;，输入字段将加载添加文本处的输入内容。无论如何，将其作为空字符串，我们在输入字段中键入的任何文本都会绑定到 todo。这实际上是双向绑定（输入字段可以更新数据对象，数据对象可以更新输入字段）。 因此，回顾前面的 createNewToDoItem() 代码块，我们将 todo 的内容存放到列表数组中 ，然后将 todo 改为空字符串。 4.删除待办事项 React 的实现方法 deleteItem = indexToDelete =&gt; { this.setState(({ list }) =&gt; ({ list: list.filter((toDo, index) =&gt; index !== indexToDelete) })); }; 尽管 deleteItem 函数位于 ToDo.js 文件中，但是从 ToDoItem.js 文件中引用它也很容易，将 deleteItem() 函数作为 上的 prop 传递： &lt;ToDoItem deleteItem={this.deleteItem.bind(this, key)}/&gt; 这会将该函数传递给子组件，使其可以访问。我们绑定了 this 并传递 key 参数，当用户点击删除项时，函数通过 key 区分用户点击的是哪一条 ToDoItem 。然后，在ToDoItem 组件内部，我们执行以下操作： &lt;div className=”ToDoItem-Delete” onClick={this.props.deleteItem}&gt;-&lt;/div&gt; 想要引用位于父组件内部的函数，只需引用 this.props.deleteItem 即可。 Vue 的实现方法 onDeleteItem(todo){ this.list = this.list.filter(item =&gt; item !== todo); } Vue 的实现方法稍有不同，我们需要做到以下三点： 首先，在元素上调用函数： &lt;div class=”ToDoItem-Delete” @click=”deleteItem(todo)”&gt;-&lt;/div&gt; 然后我们必须创建一个 emit 函数，将其作为子组件的内部方法（在本例中为ToDoItem.vue），如下所示： deleteItem(todo) { this.$emit(&#39;delete&#39;, todo) } 之后，你会发现，当我们添加 ToDo.vue的 ToDoItem.vue 时，实际上引用了一个函数： &lt;ToDoItem v-for=&#34;todo in list&#34; :todo=&#34;todo&#34; @delete=&#34;onDeleteItem&#34; // &lt;-- this :) :key=&#34;todo.id&#34; /&gt; 这就是所谓的自定义事件监听器。它会监听任何使用 &lsquo;delete&rsquo; 字符串的触发事件。一旦监听到事件，它会触发一个名为 onDeleteItem 的函数。此函数位于 ToDo.vue 内部，而不是 ToDoItem.vue。如前所述，该函数只是过滤数据对象内的 todo 数组 ，以删除被点击的待办事项。 在 Vue 示例中还需要注意的是，我们可以在 @click 侦听器中编写 $emit 部分，这样更加简单，如下所示： &lt;div class=”ToDoItem-Delete” @click=”$emit(‘delete’, todo)”&gt;-&lt;/div&gt; 如果你喜欢，这样做可以把 3 步减少到 2 步。 React 中的子组件可以通过 this.props 访问父函数，而在 Vue 中，你需要从子组件中发出事件，父组件来收集事件。 5.如何传递事件监听器 React 的实现方法 事件监听器处理简单事件（比如点击）非常直接。我们为待办事项创建了点击事件，用于创建新的待办事项，代码如下： &lt;div className=”ToDo-Add” onClick={this.createNewToDoItem}&gt;+&lt;/div&gt; 非常简单，就像使用 vanilla JS 处理内联 onClick 一样。正如前文所述，只要按下回车按钮，设置事件监听器就需要花费更长的时间。这需要输入标签处理 onKeyPress 事件，代码如下： &lt;input type=”text” onKeyPress={this.handleKeyPress}/&gt; 该函数只要识别到&rsquo;enter&rsquo;键被按下，它就会触发 createNewToDoItem 函数，代码如下所示： handleKeyPress = (e) =&gt; { if (e.key === ‘Enter’) { this.createNewToDoItem(); } }; Vue 的实现方法 Vue 的事件监听器更加直接。我们只需要使用一个简单的 @ 符号，就可以构建出我们想要的事件监听器。例如，想要添加 click 事件监听器，代码： &lt;div class=”ToDo-Add” @click=”createNewToDoItem()”&gt;+&lt;/div&gt; 注意：@click 实际上是 v-on:click 的简写。Vue 事件监听器很强大，你可以为其选择属性，例如 .once 可以防止事件监听器被多次触发。此外，它还包含很多快捷方式。按下回车按钮时，React 就需要花费更长的时间来创建事件监听器，从而创建新的 ToDo 项目。在 Vue，代码如下： &lt;input type=”text” v-on:keyup.enter=”createNewToDoItem”/&gt; 6.如何将数据传递给子组件 React 的实现方法 在 React 中，我们将 props 传递到子组件的创建处。比如： &lt;ToDoItem key={key} item={todo} /&gt; 此处我们向 ToDoItem 组件传递了两个 prop。之后，我们可以在子组件中通过 this.props 引用它们。因此，想要访问 item.todo prop，我们只需调用this.props.item 。 Vue 的实现方法 在 Vue 中，我们将 props 传递到子组件创建处的方式如下： &lt;ToDoItem v-for=&#34;todo in list&#34; :todo=&#34;todo&#34; :key=&#34;todo.id&#34; @delete=&#34;onDeleteItem&#34; /&gt; 我们将它们传递给子组件中的 props 数组，如：props：[&lsquo;id&rsquo;，&rsquo;todo&rsquo;]。然后可以在子组件中通过名字引用它们。 7.如何将数据发送回父组件 React 的实现方法 我们首先将函数传递给子组件，方法是在我们调用子组件时将其引用为 prop。然后我们通过引用 this.props.whateverTheFunctionIsCalled，为子组件添加调用函数，例如 onClick。然后，这将触发父组件中的函数。删除待办事项一节中详细介绍了整个过程。 Vue 的实现方法 在子组件中我们只需编写一个函数，将一个值发送回父函数。在父组件中编写一个函数来监听子组件何时发出该值的事件，监听到事件之后触发函数调用。同样，删除待办事项一节中详细介绍了整个过程。 8.总结 我们研究了添加、删除和更改数据，以 prop 形式从父组件到子组件传递数据，以及通过事件监听器的形式将数据从子组件发送到父组件。当然，React 和 Vue 之间存在一些小差异，希望本文的内容有助于理解这两个框架。 两个应用程序的 GitHub 地址： **Vue ToDo：**https://github.com/sunil-sandhu/vue-todo **React ToDo：**https://github.com/sunil-sandhu/react-todo</p>
    </div>
    <footer class="entry-footer">
      <time datetime=" 2021-01-06 00:00:00 UTC"> January 06, 2021</time>
    </footer>
    <a class="entry-link" aria-label="post link to Installation | Update" href="/blog/43.html/"></a>
  </article>

  
  
  

  <article class="post-entry">
    <header class="entry-header">
      <h2>React 脚手架项目打包时的路径问题</h2>
    </header>
    <div class="entry-content">
      <p>create-react-app 脚手架指令可以生成 React 项目，在项目完成之后执行打包命令 npm run build，文件夹内生成 build文件夹，就是打包后的文件，在浏览器运行 index.html 发现页面空白，打开控制台有报错，css 和 js 文件的引用路径有问题。 浏览 index.html 代码可以发现： &lt;!-- index.html --&gt; &lt;!doctype html&gt; &lt;html lang=&#34;zh&#34;&gt; &lt;head&gt; &lt;meta charset=&#34;utf-8&#34; /&gt; &lt;meta name=&#34;viewport&#34; content=&#34;width=device-width,initial-scale=1&#34; /&gt; &lt;meta name=&#34;theme-color&#34; content=&#34;#000000&#34; /&gt; &lt;meta name=&#34;description&#34; content=&#34;Web site created using create-react-app&#34; /&gt; &lt;title&gt;React App&lt;/title&gt; &lt;link href=&#34;/static/css/main.3394d54e.chunk.css&#34; rel=&#34;stylesheet&#34;&gt; &lt;/head&gt; &lt;body&gt;&lt;noscript&gt;You need to enable JavaScript to run this app.&lt;/noscript&gt; &lt;div id=&#34;root&#34;&gt;&lt;/div&gt; &lt;script&gt;!function (e) { function r(r) { for (var n, l, f = r[0], i = r[1], a = r[2], c = 0, s = []; c &lt; f.length; c++)l = f[c], Object.prototype.hasOwnProperty.call(o, l) &amp;&amp; o[l] &amp;&amp; s.push(o[l][0]), o[l] = 0; for (n in i) Object.prototype.hasOwnProperty.call(i, n) &amp;&amp; (e[n] = i[n]); for (p &amp;&amp; p(r); s.length;)s.shift()(); return u.push.apply(u, a || []), t() } function t() { for (var e, r = 0; r &lt; u.length; r++) { for (var t = u[r], n = !0, f = 1; f &lt; t.length; f++) { var i = t[f]; 0 !== o[i] &amp;&amp; (n = !1) } n &amp;&amp; (u.splice(r--, 1), e = l(l.s = t[0])) } return e } var n = {}, o = { 1: 0 }, u = []; function l(r) { if (n[r]) return n[r].exports; var t = n[r] = { i: r, l: !1, exports: {} }; return e[r].call(t.exports, t, t.exports, l), t.l = !0, t.exports } l.m = e, l.c = n, l.d = function (e, r, t) { l.o(e, r) || Object.defineProperty(e, r, { enumerable: !0, get: t }) }, l.r = function (e) { &#34;undefined&#34; != typeof Symbol &amp;&amp; Symbol.toStringTag &amp;&amp; Object.defineProperty(e, Symbol.toStringTag, { value: &#34;Module&#34; }), Object.defineProperty(e, &#34;__esModule&#34;, { value: !0 }) }, l.t = function (e, r) { if (1 &amp; r &amp;&amp; (e = l(e)), 8 &amp; r) return e; if (4 &amp; r &amp;&amp; &#34;object&#34; == typeof e &amp;&amp; e &amp;&amp; e.__esModule) return e; var t = Object.create(null); if (l.r(t), Object.defineProperty(t, &#34;default&#34;, { enumerable: !0, value: e }), 2 &amp; r &amp;&amp; &#34;string&#34; != typeof e) for (var n in e) l.d(t, n, function (r) { return e[r] }.bind(null, n)); return t }, l.n = function (e) { var r = e &amp;&amp; e.__esModule ? function () { return e.default } : function () { return e }; return l.d(r, &#34;a&#34;, r), r }, l.o = function (e, r) { return Object.prototype.hasOwnProperty.call(e, r) }, l.p = &#34;./&#34;; var f = this.webpackJsonpdemo = this.webpackJsonpdemo || [], i = f.push.bind(f); f.push = r, f = f.slice(); for (var a = 0; a &lt; f.length; a++)r(f[a]); var p = i; t() }([])&lt;/script&gt; &lt;script src=&#34;/static/js/2.1902eda2.chunk.js&#34;&gt;&lt;/script&gt; &lt;script src=&#34;/static/js/main.cbf35db7.chunk.js&#34;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 发现 css 和 js 文件都是用绝对路径引用的，这是 webpack 打包一贯拥有的问题，将 /static 改成 ./static ，再运行，页面没有问题成功显示。 但是在写实际项目的时候手动修改相对路径，不但麻烦，而且容易引起其他问题。因此直接在项目的 package.json 配置文件进行修改，添加 &quot;homepage&quot;: &quot;.&quot; // package.json { &#34;name&#34;: &#34;demo&#34;, &#34;version&#34;: &#34;0.1.0&#34;, &#34;private&#34;: true, &#34;homepage&#34;: &#34;.&#34;, // 添加这一行 &#34;dependencies&#34;: { &#34;@babel/core&#34;: &#34;7.12.3&#34;, ... 然后再执行 npm run build ，运行打包后的文件，没有任何问题。</p>
    </div>
    <footer class="entry-footer">
      <time datetime=" 2021-01-05 00:00:00 UTC"> January 05, 2021</time>
    </footer>
    <a class="entry-link" aria-label="post link to Installation | Update" href="/blog/42.html/"></a>
  </article>

  
  
  

  <article class="post-entry">
    <header class="entry-header">
      <h2>如何在 React 中引入 less？</h2>
    </header>
    <div class="entry-content">
      <p>本文主要写如何在 React 中引入 less 。因为 less 和 css 非常像，因此很容易学习。而且 less 仅对 css 语言增加了少许方便的扩展，这就是 less 如此易学的原因之一。 1.安装 less npm install less less-loader --save-dev 2.暴露 webpack 文件 利用 npx create-react-app 搭建的 React 项目，默认隐藏 webpack 配置文件，引入 less 需要修改 webpack 配置文件，因此我们需要执行命令暴露 webpack 配置文件。 这里需要注意，一旦暴露，无法回退。 npm run eject 如果这一步失败，执行下列命令： git add . git commit -m &#34;init&#34; 然后再执行 npm run eject 注意：暴露 webpack 文件只能在 create-react-app 之初，一旦项目结构发生改变，再进行暴露操作就会失败。所以尽量在项目建立时就进行 npm run eject 操作。 3.修改 wenpack.config.js 配置 在合适的位置添加： // 放在 // const sassRegex = /\.(scss|sass)$/; // const sassModuleRegex = /\.module\.(scss|sass)$/; // 后面 const lessRegex = /\.less$/; const lessModuleRegex = /\.module\.less$/; // 放在 oneof 数组下 { test: lessRegex, exclude: lessModuleRegex, use: getStyleLoaders( { importLoaders: 2, sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap, }, &#39;less-loader&#39; ), // Don&#39;t consider CSS imports dead code even if the // containing package claims to have no side effects. // Remove this when webpack adds a warning or an error for this. // See https://github.com/webpack/webpack/issues/6571 sideEffects: true, }, // Adds support for CSS Modules, but using SASS // using the extension .module.scss or .module.sass { test: lessModuleRegex, use: getStyleLoaders( { importLoaders: 2, sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap, modules: true, getLocalIdent: getCSSModuleLocalIdent, }, &#39;less-loader&#39; ), }, 4.如何使用 less 新建一个 App.less 文件，然后在 App.js 中引入： import &#39;./Map.less&#39; less 语法手册</p>
    </div>
    <footer class="entry-footer">
      <time datetime=" 2021-01-04 00:00:00 UTC"> January 04, 2021</time>
    </footer>
    <a class="entry-link" aria-label="post link to Installation | Update" href="/blog/41.html/"></a>
  </article>

  
  
  

  <article class="post-entry">
    <header class="entry-header">
      <h2>为什么 key 是必须的？</h2>
    </header>
    <div class="entry-content">
      <p>之前有说到，在 React 中渲染列表的时候，要给每一个数据加一个 key 值，赋予一个确定的标示，而且也详细描述了如何给一个标示，方法知道了，那么为什么要这么做呢？ 在 React 中如何渲染列表？ 在默认条件下，当递归 DOM 节点的子元素时，React 会同时遍历两个子元素的列表；当产生差异时，生成一个 mutation。 在子元素列表末尾新增元素时，更新开销比较小。比如： &lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt; &lt;li&gt;third&lt;/li&gt; &lt;/ul&gt; React 会先匹配两个 &lt;li&gt;first&lt;/li&gt; 对应的树，然后匹配第二个元素 &lt;li&gt;second&lt;/li&gt; 对应的树，最后插入第三个元素的 &lt;li&gt;third&lt;/li&gt; 树。 如果只是简单的将新增元素插入到表头，那么更新开销会比较大。比如： &lt;ul&gt; &lt;li&gt;Duke&lt;/li&gt; &lt;li&gt;Villanova&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li&gt;Connecticut&lt;/li&gt; &lt;li&gt;Duke&lt;/li&gt; &lt;li&gt;Villanova&lt;/li&gt; &lt;/ul&gt; React 不会意识到应该保留 &lt;li&gt;Duke&lt;/li&gt; 和 &lt;li&gt;Villanova&lt;/li&gt;，而是会重建每一个子元素 。这种情况会带来性能问题。 key 为了解决上述问题， React 支持 key 属性，当子元素拥有 key 时，React 使用 key 来匹配原有树上的子元素以及最新树上的子元素。以下例子在新增 key 之后使得之前的低效转换变得高效： &lt;ul&gt; &lt;li key=&#34;1&#34;&gt;Duke&lt;/li&gt; &lt;li key=&#34;2&#34;&gt;Villanova&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li key=&#34;0&#34;&gt;Connecticut&lt;/li&gt; &lt;li key=&#34;1&#34;&gt;Duke&lt;/li&gt; &lt;li key=&#34;2&#34;&gt;Villanova&lt;/li&gt; &lt;/ul&gt; 现在 React 知道只有带着 '0' key 的元素是新元素，带着 '1' 以及 '2' key 的元素仅仅移动了。 现实场景中，产生一个 key 并不困难。你要展现的元素可能已经有了一个唯一 ID，于是 key 可以直接从你的数据中提取： &lt;li key={item.id}&gt;{item.name}&lt;/li&gt; 当以上情况不成立时，你可以新增一个 ID 字段到你的模型中，或者利用一部分内容作为哈希值来生成一个 key。这个 key 不需要全局唯一，但在列表中需要保持唯一。 最后，你也可以使用元素在数组中的下标作为 key。这个策略在元素不进行重新排序时比较合适，如果有顺序修改，diff 就会变得慢。 当基于下标的组件进行重新排序时，组件 state 可能会遇到一些问题。由于组件实例是基于它们的 key 来决定是否更新以及复用，如果 key 是一个下标，那么修改顺序时会修改当前的 key，导致非受控组件的 state（比如输入框）可能相互篡改导致无法预期的变动。</p>
    </div>
    <footer class="entry-footer">
      <time datetime=" 2021-01-01 00:00:00 UTC"> January 01, 2021</time>
    </footer>
    <a class="entry-link" aria-label="post link to Installation | Update" href="/blog/40.html/"></a>
  </article>

  
  
  

  <article class="post-entry">
    <header class="entry-header">
      <h2>React 学习笔记（三）</h2>
    </header>
    <div class="entry-content">
      <p>来源于：https://react.docschina.org/docs/forms.html 一、表单 在 React 中，html 表单元素的工作方式和其他的 DOM 元素不太一样，因为表单内部通常会保持一些内部的 state，比如下面这个纯 html 表单只接受一个名称： &lt;form&gt; &lt;label&gt; 名字: &lt;input type=&#34;text&#34; name=&#34;name&#34; /&gt; &lt;/label&gt; &lt;input type=&#34;submit&#34; value=&#34;提交&#34; /&gt; &lt;/form&gt; 这个表单具有默认的 html 表单行为，即在用户提交表单之后自动刷新页面。如果你在 React 中执行相同的代码，它仍然有效。 但大多数情况下，使用 JavaScript 函数可以很方便的处理表单的提交， 同时还可以访问用户填写的表单数据。实现这种效果的标准方式是使用“受控组件”。 受控组件 在 html 中，表单元素比如&lt;input&gt;，&lt;textarea&gt;，&lt;select&gt;，这些表单元素通常自己维护 state，并根据用户输入进行更新。而在 React 中，可变状态（mutable state）通常保存在组件的 state 属性中，并且只能通过使用 setState() 来更新。 我们可以把两者结合起来，使 React 的 state 成为“唯一数据源”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”。 例如，如果我们想让前一个示例在提交时打印出名称，我们可以将表单写为受控组件： class NameForm extends React.Component { constructor(props) { super(props); this.state = {value: &#39;&#39;}; this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); } handleChange(event) { this.setState({value: event.target.value}); } handleSubmit(event) { alert(&#39;提交的名字: &#39; + this.state.value); event.preventDefault(); } render() { return ( &lt;form onSubmit={this.handleSubmit}&gt; &lt;label&gt; 名字: &lt;input type=&#34;text&#34; value={this.state.value} onChange={this.handleChange} /&gt; &lt;/label&gt; &lt;input type=&#34;submit&#34; value=&#34;提交&#34; /&gt; &lt;/form&gt; ); } } 由于在表单元素上设置了 value 属性，因此显示的值将始终为 this.state.value，这使得 React 的 state 成为唯一数据源。由于 handlechange 在每次按键时都会执行并更新 React 的 state，因此显示的值将随着用户输入而更新。 对于受控组件来说，输入的值始终由 React 的 state 驱动。你也可以将 value 传递给其他 UI 元素，或者通过其他事件处理函数重置，但这意味着你需要编写更多的代码。 textarea 标签 在 html 中，&lt;textarea&gt; 元素通过其子元素定义其文本： &lt;textarea&gt; 测试！ &lt;/textarea&gt; 而在 React 中，&lt;textarea&gt; 使用 value 属性代替。这样，可以使得使用 &lt;textarea&gt; 的表单和使用单行 input 的表单非常类似： class EssayForm extends React.Component { constructor(props) { super(props); this.state = { value: &#39;请撰写一篇关于你喜欢的 DOM 元素的文章.&#39; }; this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); } handleChange(event) { this.setState({value: event.target.value}); } handleSubmit(event) { alert(&#39;提交的文章: &#39; + this.state.value); event.preventDefault(); } render() { return ( &lt;form onSubmit={this.handleSubmit}&gt; &lt;label&gt; 文章: &lt;textarea value={this.state.value} onChange={this.handleChange} /&gt; &lt;/label&gt; &lt;input type=&#34;submit&#34; value=&#34;提交&#34; /&gt; &lt;/form&gt; ); } } 请注意，this.state.value 初始化于构造函数中，因此文本区域默认有初值。 select 标签 在 HTML 中，&lt;select&gt; 创建下拉列表标签。例如，如下 html 创建了水果相关的下拉列表： &lt;select&gt; &lt;option value=&#34;grapefruit&#34;&gt;葡萄柚&lt;/option&gt; &lt;option value=&#34;lime&#34;&gt;酸橙&lt;/option&gt; &lt;option selected value=&#34;coconut&#34;&gt;椰子&lt;/option&gt; &lt;option value=&#34;mango&#34;&gt;芒果&lt;/option&gt; &lt;/select&gt; 请注意，由于 selected 属性的缘故，椰子选项默认被选中。React 并不会使用 selected 属性，而是在根 select 标签上使用 value 属性。这在受控组件中更便捷，因为您只需要在根标签中更新它。例如： class FlavorForm extends React.Component { constructor(props) { super(props); this.state = {value: &#39;coconut&#39;}; this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); } handleChange(event) { this.setState({value: event.target.value}); } handleSubmit(event) { alert(&#39;你喜欢的风味是: &#39; + this.state.value); event.preventDefault(); } render() { return ( &lt;form onSubmit={this.handleSubmit}&gt; &lt;label&gt; 选择你喜欢的风味: &lt;select value={this.state.value} onChange={this.handleChange}&gt; &lt;option value=&#34;grapefruit&#34;&gt;葡萄柚&lt;/option&gt; &lt;option value=&#34;lime&#34;&gt;酸橙&lt;/option&gt; &lt;option value=&#34;coconut&#34;&gt;椰子&lt;/option&gt; &lt;option value=&#34;mango&#34;&gt;芒果&lt;/option&gt; &lt;/select&gt; &lt;/label&gt; &lt;input type=&#34;submit&#34; value=&#34;提交&#34; /&gt; &lt;/form&gt; ); } } 总的来说，这使得 &lt;input type=&quot;text&quot;&gt;, &lt;textarea&gt; 和 &lt;select&gt; 之类的标签都非常相似—它们都接受一个 value 属性，你可以使用它来实现受控组件。 注意:你可以将数组传递到 value 属性中，以支持在 select 标签中选择多个选项： &lt;select multiple={true} value={[&#39;B&#39;, &#39;C&#39;]}&gt; 文件 input 标签 在 HTML 中，&lt;input type=&quot;file&quot;&gt; 允许用户从存储设备中选择一个或多个文件，将其上传到服务器，或通过使用 JavaScript 的 File API 进行控制。 &lt;input type=&#34;file&#34; /&gt; 因为它的 value 只读，所以它是 React 中的一个非受控组件。 处理多个输入 当需要处理多个 input 元素时，我们可以给每个元素添加 name 属性，并让处理函数根据 event.target.name 的值选择要执行的操作。 class Reservation extends React.Component { constructor(props) { super(props); this.state = { isGoing: true, numberOfGuests: 2 }; this.handleInputChange = this.handleInputChange.bind(this); } handleInputChange(event) { const target = event.target; const value = target.name === &#39;isGoing&#39; ? target.checked : target.value; const name = target.name; this.setState({ [name]: value }); } render() { return ( &lt;form&gt; &lt;label&gt; 参与: &lt;input name=&#34;isGoing&#34; type=&#34;checkbox&#34; checked={this.state.isGoing} onChange={this.handleInputChange} /&gt; &lt;/label&gt; &lt;br /&gt; &lt;label&gt; 来宾人数: &lt;input name=&#34;numberOfGuests&#34; type=&#34;number&#34; value={this.state.numberOfGuests} onChange={this.handleInputChange} /&gt; &lt;/label&gt; &lt;/form&gt; ); } } 这里使用了 ES6 计算属性名称的语法更新给定输入名称对应的 state 值： 例如： this.setState({ [name]: value }); 等同于 es5： var partialState = {}; partialState[name] = value; this.setState(partialState); 另外，由于 setState() 自动将部分 state 合并到当前 state, 只需调用它更改部分 state 即可。 受控输入空值 在受控组件上指定 value 的 prop 会阻止用户更改输入。如果你指定了 value，但输入仍可编辑，则可能是你意外地将 value 设置为 undefined 或 null。 下面的代码演示了这一点。（输入最初被锁定，但在短时间延迟后变为可编辑。） ReactDOM.render(&lt;input value=&#34;hi&#34; /&gt;, mountNode); setTimeout(function() { ReactDOM.render(&lt;input value={null} /&gt;, mountNode); }, 1000); 受控组件的替代品 有时使用受控组件会很麻烦，因为你需要为数据变化的每种方式都编写事件处理函数，并通过一个 React 组件传递所有的输入 state。当你将之前的代码库转换为 React 或将 React 应用程序与非 React 库集成时，这可能会令人厌烦。在这些情况下，你可能希望使用非受控组件, 这是实现输入表单的另一种方式。 成熟的解决方案 如果你想寻找包含验证、追踪访问字段以及处理表单提交的完整解决方案，使用 Formik 是不错的选择。然而，它也是建立在受控组件和管理 state 的基础之上 —— 所以不要忽视学习它们。</p>
    </div>
    <footer class="entry-footer">
      <time datetime=" 2020-12-29 00:00:00 UTC"> December 29, 2020</time>
    </footer>
    <a class="entry-link" aria-label="post link to Installation | Update" href="/blog/39.html/"></a>
  </article>

  

  



















<div class="page">
  
  <a href="/page/19/" class="prev">上一页</a>
  

  
  <a href="/page/21/" class="next">下一页</a>
  


</div>



</div>
</div>
</main>

<footer class="footer">
  <div>© 2020 - <span id="year"></span> Powered by 子舒</div>
  <div>网站已经运行 <span id="days">0</span></div>
  <div class="gotop">▲</div>
</footer>

<script>
  var s0 = '2020-06-14';
  s1 = new Date(s0.replace(/-/g, "/"));
  s2 = new Date();
  var days = s2.getTime() - s1.getTime();

  var date = new Date;
  var year = date.getFullYear();
  document.getElementById('year').innerHTML = year;

  var BootDate = new Date("2020-06-14");
  function ShowRunTime(id) {
    var NowDate = new Date();
    var RunDateM = parseInt(NowDate - BootDate);
    var RunDays = Math.floor(RunDateM / (24 * 3600 * 1000));
    var RunHours = Math.floor(RunDateM % (24 * 3600 * 1000) / (3600 * 1000));
    var RunMinutes = Math.floor(RunDateM % (24 * 3600 * 1000) % (3600 * 1000) / (60 * 1000));
    var RunSeconds = Math.round(RunDateM % (24 * 3600 * 1000) % (3600 * 1000) % (60 * 1000) / 1000);
    var days = RunDays + "天" + RunHours + "时" + RunMinutes + "分" + RunSeconds + "秒";
    document.getElementById(id).innerHTML = days;
  }
  ShowRunTime('days');
  setInterval("ShowRunTime('days')", 1000);
</script>
<script src="/js/simplebox.min.js"></script>
<script src="/js/search.js"></script>
<script src="/js/main.js"></script>
</body>

</html>